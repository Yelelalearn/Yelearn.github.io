<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Swin Transformer</title>
    <link href="/2024/04/16/Swin-Transformer/"/>
    <url>/2024/04/16/Swin-Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="swin-transformer使用偏移窗口的分层视觉变换器">SwinTransformer：使用偏移窗口的分层视觉变换器</h1><p>Swin Transformer: Hierarchical Vision Transformer using ShiftedWindows</p><h2 id="摘要">摘要</h2><p>本论文提出了一种名为SwinTransformer的新型视觉Transformer模型，它能够作为通用的计算机视觉骨干网络。</p><span id="more"></span><p>从语言到视觉的Transformer模型的适应性挑战源于两个领域之间的差异，如视觉实体的尺度变化较大以及图像中像素的高分辨率相对于文本中的单词。为了解决这些差异，我们提出了一种分层Transformer，其表示是通过<em>偏移窗口</em>计算的。偏移窗口方案通过将自注意力计算限制<strong>在非重叠的本地窗口内</strong>，同时也允许跨窗口连接，从而带来了更高的效率。这种分层架构具有在不同尺度上建模的灵活性，并且在图像大小方面具有<em>线性的计算复杂度</em>。SwinTransformer的这些特性使其与广泛范围的视觉任务兼容，包括图像分类（在ImageNet-1K上的87.3的top-1准确度）以及密集预测任务，如目标检测（在COCO测试集上的58.7的boxAP和51.1的maskAP）和语义分割（在ADE20K验证集上的53.5的mIoU）。其性能大大超越了先前的最先进技术，分别在COCO上提升了+2.7的boxAP和+2.6的maskAP，并在ADE20K上提升了+3.2的mIoU，显示了基于Transformer的模型作为视觉骨干的潜力。分层设计和偏移窗口方法也对所有MLP架构具有益处。代码和模型可以在<ahref="https://github.com/microsoft/Swin-Transformer">https://github.com/microsoft/Swin-Transformer</a>上公开获取。</p><h2 id="引言">1、引言</h2><p>计算机视觉中的建模长期以来一直由卷积神经网络（CNNs）主导。从AlexNet的问世以及它在ImageNet图像分类挑战中的革命性表现开始，CNN架构通过规模的扩大、连接的加强以及更复杂形式的卷积等方式变得越来越强大。由于CNNs在各种视觉任务中作为骨干网络，这些架构的进步导致了性能的提升，从而广泛推动了整个领域的发展。</p><p>另一方面，在自然语言处理（NLP）中，网络架构的演变走上了一条不同的道路，如今普遍的架构是Transformer。Transformer设计用于序列建模和转录任务，其以使用注意力机制来建模数据中的长距离依赖关系而引人注目。它在语言领域取得了巨大的成功，这导致研究人员研究如何将其应用于计算机视觉，最近在特定任务上取得了有希望的结果，特别是在图像分类和联合视觉-语言建模方面。</p><p>在本论文中，我们试图扩展Transformer的适用性，使其能够像在NLP中一样成为计算机视觉的通用骨干网络，就像CNN在视觉中一样。我们观察到，在将其在语言领域的高性能转移到视觉领域时，存在着显著的挑战，这可以通过两种模态之间的差异来解释。其中之一涉及到尺度。与在语言Transformer中作为处理基本单元的单词标记不同，视觉元素的尺度可以有很大的变化，这在诸如目标检测等任务中受到关注。在现有的基于Transformer的模型中，标记都是固定尺度的，这在视觉应用中不合适。另一个差异是图像中像素的分辨率要比文本段落中的单词高得多。存在许多像语义分割这样的视觉任务需要在像素级别进行密集预测，对于高分辨率图像来说，这将变得棘手，因为其自注意力的计算复杂度与图像尺寸的平方成正比。<em>为了克服这些问题</em> ，我们提出了一个名为SwinTransformer的通用Transformer骨干网络，它构建了分层特征图，并具有线性的图像大小计算复杂度。如<ahref="#图1">图1(a)</a>所示，SwinTransformer通过从小尺寸的图块开始（用灰色轮廓标出）并逐渐合并深层Transformer层中的相邻图块来构建分层表示。借助这些分层特征图，SwinTransformer模型可以方便地利用高级技术进行像素级别的密集预测，如特征金字塔网络（FPN）或U-Net。通过在划分图像的非重叠窗口内局部计算自注意力来实现线性的计算复杂度（用红色轮廓标出）。每个窗口中的图块数量是固定的，因此复杂度变为与图像大小成线性关系。这些优点使得SwinTransformer能够成为各种视觉任务的通用骨干网络，与之前的基于Transformer的架构形成对比，后者只能生成单一分辨率的特征图，并具有二次复杂度。</p><p><img src="https://pic.imgdb.cn/item/661e0a7c0ea9cb1403e039f2.png" alt="tu_1" style="zoom:67%;" /></p><div data-align="center"><strong><a name="图1">图1. (a) 提出的SwinTransformer通过在更深的层次中合并图像块（灰色显示）来构建分层特征图，并且由于仅在每个本地窗口内计算自注意力（红色显示），它对输入图像大小具有线性的计算复杂度。因此，它可以作为图像分类和密集识别任务的通用骨干网络。(b) 相比之下，先前的视觉Transformer [20]生成单一低分辨率的特征图，并且由于在全局范围内计算自注意力，对输入图像大小具有二次计算复杂度。</a></strong></div><p>SwinTransformer的一个关键设计元素是在连续的自注意层之间移动窗口划分，如<ahref="#图2">图2</a>所示。</p><p><img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03aa9.png" alt="img" style="zoom: 33%;" /></p><div data-align="center"><strong><a name="图2">图2. 展示了在提议的SwinTransformer架构中计算自注意力的移位窗口方法。在第l层（左侧），采用了常规的窗口分区方案，并在每个窗口内计算自注意力。在下一层l+1（右侧），窗口分区被移位，产生了新的窗口。在新窗口中的自注意力计算穿越了第l层中先前窗口的边界，从而在它们之间建立了连接。</a></strong></div><p>移动的窗口连接了前一层的窗口，提供了它们之间的连接，显著增强了建模能力（参见<ahref="#表4">表4</a>）。这种策略在实际应用的延迟方面也很高效：<u>窗口内的所有查询块共享相同的键集</u>，这有利于硬件中的内存访问。相比之下，早期基于滑动窗口的自注意方法在一般硬件上存在延迟较低的问题，因为不同的查询像素有不同的键集。我们的实验证明，所提出的移动窗口方法比滑动窗口方法具有更低的延迟，但在建模能力上类似（见<ahref="#表5">表5</a>和<ahref="#表6">表6</a>）。<em>移动窗口方法也对所有MLP架构具有益处</em>。</p><p>所提出的SwinTransformer在图像分类、目标检测和语义分割等识别任务上取得了强劲的性能。它在这三个任务上的性能显著优于ViT/ DeiT [20, 63] 和ResNe(X)t模型 [30,70]，并且具有类似的延迟。其在COCO测试集的58.7的box AP和51.1的maskAP超过了先前最先进的结果，分别提高了+2.7的box AP（无外部数据的Copy-paste[26]）和+2.6的mask AP（DetectoRS[46]）。在ADE20K语义分割任务中，它在验证集上获得了53.5的mIoU，比先前最先进的SETR[81]提高了+3.2的mIoU。在ImageNet-1K图像分类任务中，它实现了87.3%的top-1准确度。</p><p>我们相信，在计算机视觉和自然语言处理之间采用统一的架构可以使两个领域受益，因为它将便于对视觉和文本信号进行联合建模，并且可以更深入地共享两个领域的建模知识。我们希望SwinTransformer在各种视觉问题上的优异性能可以在社区中深化这种信念，并鼓励对视觉和语言信号进行统一建模。</p><h2 id="相关工作">2、 相关工作</h2><p><strong>CNN及其变体</strong>CNN（卷积神经网络）在整个计算机视觉领域作为标准网络模型。虽然CNN已经存在了几十年[40]，但直到AlexNet的引入[39]，CNN才起飞并成为主流。自那时以来，人们提出了更深层次、更有效的卷积神经网络架构，进一步推动了计算机视觉中的深度学习浪潮，例如VGG[52]、GoogleNet [57]、ResNet [30]、DenseNet [34]、HRNet[65]和EfficientNet [58]等。</p><p>除了这些架构的进步，还有许多关于改进单个卷积层的工作，如深度卷积[70]和可变形卷积[18,84]。虽然CNN及其变体仍然是计算机视觉应用的主要骨干架构，但我们强调了类似Transformer的架构在视觉和语言之间进行统一建模的巨大潜力。我们的工作在几个基本的视觉识别任务上取得了强劲的性能，我们希望它能对模型的发展方向做出一定的贡献。</p><p><strong>基于自注意力的骨干网络架构</strong>受到自注意力层和Transformer在自然语言处理领域的成功启发，一些研究利用自注意力层来替代流行的ResNet中的一些或全部空间卷积层[33,50,80]。在这些研究中，自注意力是在每个像素的局部窗口内计算的，以加速优化过程[33]，并且它们在准确性和计算量之间取得了稍微更好的平衡，相比于ResNet架构。然而，它们昂贵的内存访问导致了实际延迟明显大于卷积网络[33]。我们提出了在连续层之间移动窗口的方法，而不是使用滑动窗口，这使得在通用硬件上能够更高效地实现。</p><p><strong>自注意力/Transformer以补充CNN</strong>另一方面，一些工作尝试将标准的CNN架构与自注意力层或Transformer相结合。自注意力层可以通过提供编码远程依赖关系或异质交互的能力来增强骨干网络[67,7, 3, 71, 23, 74, 55]或头部网络[32,27]。最近，Transformer中的编码-解码设计已经应用于目标检测和实例分割任务[8,13, 85,56]。我们的工作探索了将Transformer用于基本视觉特征提取的适应性，与这些工作相辅相成。</p><p><strong>基于Transformer的视觉骨干网络</strong>与我们的工作最相关的是Vision Transformer（ViT）[20]及其后续研究[63, 72,15, 28,66]。ViT的开创性工作直接将Transformer架构应用于非重叠的中等大小图像块，用于图像分类。与卷积网络相比，它在图像分类方面取得了令人印象深刻的速度-准确性平衡。虽然ViT需要大规模训练数据集（如JFT-300M）才能表现良好，但DeiT[63]引入了一些训练策略，使得ViT在使用较小的ImageNet-1K数据集时也能有效。ViT在图像分类任务上的结果令人鼓舞，但其架构不适用于作为密集视觉任务的通用骨干网络，或者当输入图像分辨率较高时，由于其低分辨率的特征图以及与图像大小成二次方增加的复杂度。</p><p>有一些研究将ViT模型应用于目标检测和语义分割等密集视觉任务，通过直接上采样或反卷积的方式，但性能相对较低[2,81]。与我们同时进行的工作是一些修改ViT架构以获得更好图像分类性能的研究[72,15, 28]。经验上，我们发现我们的SwinTransformer架构在图像分类方面在这些方法中实现了最佳的速度-准确性平衡，尽管我们的工作侧重于通用性能而不是专门分类。</p><p>另一项同时进行的工作[66]探索了一条类似的思路，以在Transformers中构建多分辨率特征图。它的复杂度仍然与图像大小成二次方，而我们的复杂度是线性的，同时也是在本地操作的，这在建模视觉信号中的高相关性方面已被证明是有效的。我们的方法既高效又有效，实现了在COCO目标检测和ADE20K语义分割上的最先进准确性。</p><h2 id="模型">3、 模型</h2><h3 id="总体架构">3.1 总体架构</h3><p><a href="#图3">图3</a>展示了SwinTransformer架构的概览，图中展示了迷你版本（Swin-T）。</p><figure><img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03b13.png"alt="tu_3" /><figcaption aria-hidden="true">tu_3</figcaption></figure><div data-align="center"><strong><a name="图3">图3. (a) Swin Transformer（Swin-T）的架构；(b)两个连续的SwinTransformer块（使用方程（3）的符号表示）。W-MSA和SW-MSA分别是具有常规和移位窗口配置的多头自注意力模块。</a></strong></div><p>首先，它通过一个补丁分割模块将输入的RGB图像分割成非重叠的补丁，类似于ViT。每个补丁被视为一个“标记”，其特征被设置为原始像素RGB值的连接。在我们的实现中，我们使用了一个4×4的补丁大小，因此每个补丁的特征维度为<span class="math inline">\(4×4×3=48\)</span>。然后，在这个原始值特征上应用一个线性嵌入层，将其投影到一个任意维度（记作<span class="math inline">\(C\)</span> ）。</p><p>对这些补丁标记应用了多个带有修改的自注意力计算的Transformer块（称为SwinTransformer块）。这些Transformer块保持了标记的数量（<spanclass="math inline">\({H\over4} ×{W\over4}\)</span>），与线性嵌入一起被称为“<strong>阶段</strong>1”。</p><p>为了产生一个分层表示，随着网络变得更深，标记的数量通过补丁合并层进行减少。第一个补丁合并层将每组<span class="math inline">\(2×2\)</span>相邻补丁的特征连接起来，并在4C维度的连接特征上应用一个线性层。这将标记的数量减少了<span class="math inline">\(2×2=4\)</span> 倍（分辨率降低了 <spanclass="math inline">\(2\)</span> 倍），输出维度设置为 <spanclass="math inline">\(2C\)</span> 。随后，应用SwinTransformer块进行特征变换，分辨率保持在 <spanclass="math inline">\({H\over8} × {W\over8}\)</span>。这个第一个补丁合并和特征变换的阶段被标记为<strong>“阶段2”</strong>。这个过程重复两次，分别作为<strong>“阶段3”</strong>和<strong>“阶段4”</strong>，输出分辨率分别为<span class="math inline">\({H\over16} × {W\over16}\)</span> 和 <spanclass="math inline">\({H\over32}× {W\over32}\)</span>。这些阶段共同产生了一个分层表示，其特征图分辨率与典型的卷积网络（如VGG[52] 和 ResNet [30]）相同。</p><p>因此，所提出的架构可以方便地替代现有方法中的骨干网络，用于各种视觉任务。</p><p><strong>Swin Transformer块</strong> SwinTransformer通过将Transformer块中的标准多头自注意力（MSA）模块替换为基于移动窗口的模块（在第3.2节中描述），同时保持其他层不变而构建。如<ahref="#图3">图3(b)</a>所示，一个SwinTransformer块包括一个基于移动窗口的MSA模块，后跟一个包含GELU非线性的2层MLP。在每个MSA模块和每个MLP之前都应用了一个LayerNorm（LN）层，并在每个模块后应用了一个残差连接。</p><h3 id="基于移动窗口的自注意力">3.2. 基于移动窗口的自注意力</h3><p>标准的Transformer架构[64]以及其用于图像分类的调整版本[20]都进行全局自注意力计算，其中计算了一个标记与所有其他标记之间的关系。全局计算导致了相对于标记数量的二次复杂度，这使得它在许多需要大量标记进行密集预测或表示高分辨率图像的视觉问题中不适用。</p><p><strong>非重叠窗口内的自注意力</strong></p><p>为了实现高效建模，我们提议在本地窗口内计算自注意力。这些窗口以非重叠的方式均匀划分图像。假设每个窗口包含<span class="math inline">\(M × M\)</span>个补丁，全局MSA模块和基于图像的窗口的计算复杂度分别如下：</p><p><span class="math display">\[Ω(MSA) = 4hwC² + 2(hw)²C，\]</span></p><p><span class="math display">\[Ω(W-MSA) = 4hwC² + 2M²hwC,\]</span></p><p>其中前者相对于补丁数量 <span class="math inline">\(hw\)</span>是二次复杂度，而后者在固定 <span class="math inline">\(M\)</span>（默认为 <span class="math inline">\(7\)</span> ）时是线性的。对于大的<span class="math inline">\(hw\)</span>值，全局自注意力计算通常是无法承受的，而基于窗口的自注意力是可扩展的。</p><p><strong>连续模块中的移动窗口划分</strong>基于窗口的自注意力模块缺乏窗口之间的连接，这限制了其建模能力。为了在保持非重叠窗口的高效计算的同时引入跨窗口连接，我们提出了一种移动窗口划分方法，在连续的SwinTransformer块中交替使用两种划分配置。</p><p>如<ahref="#图2">图2</a>表示，第一个模块使用常规的窗口划分策略，从左上角像素开始，<span class="math inline">\(8×8\)</span> 的特征图被均匀划分成 <spanclass="math inline">\(4×4\)</span> 大小的 <spanclass="math inline">\(2×2\)</span> 窗口（ <span class="math inline">\(M= 4\)</span>）。然后，下一个模块采用了一个窗口配置，它从前一层的配置中移位，通过将窗口从常规划分的窗口中移动（<span class="math inline">\(\lfloor M/2，M/2\rfloor\)</span>）个像素。</p><p><span class="math inline">\(\hat{z}^{l}=W-MSA(LN(z^{l-1}))+z^{l-1},\\\)</span></p><p><span class="math inline">\(z^l=MLP(LN(\hat{z}^l))+\hat{z}^l,\\\)</span></p><p>$<sup>{l+1}=SW-MSA(LN(z</sup>l))+z^l, \ $</p><p><spanclass="math inline">\(z^{l+1}=MLP(LN(\hat{z}^{l+1}))+\hat{z}^{l+1},\\\)</span></p><p>这里 <span class="math inline">\(\hat{z}^{l}\)</span> 和 <spanclass="math inline">\({z}^{l}\)</span> 分别表示块 <spanclass="math inline">\(l\)</span> 的 (S)W-MSA 模块和 MLP模块的输出特征；W-MSA 和 SW-MSA分别表示基于常规和移动窗口划分配置的窗口式多头自注意力。</p><p>移动窗口划分方法在前一层中引入了相邻非重叠窗口之间的连接，并在图像分类、目标检测和语义分割等任务中被发现是有效的，如<ahref="#表4">表4</a>所示。</p><p><strong>对于移动配置的高效批处理计算</strong>移动窗口划分的一个问题是它会导致更多的窗口，从 <spanclass="math inline">\(\lceil {h\over M}\rceil \times \lceil {w\overM}\rceil\)</span> 到 <span class="math inline">\((\lceil {h\overM}\rceil+1 )\times (\lceil {w\over M}\rceil+1)\)</span>在移动配置中，其中一些窗口将小于 <span class="math inline">\(M ×M\)</span> 。一个简单的解决方案是将较小的窗口填充到 <spanclass="math inline">\(M × M\)</span>的大小，并在计算注意力时将填充的值屏蔽掉。当常规划分中窗口的数量较小时，例如<span class="math inline">\(2 × 2\)</span>，采用这种简单解决方案会导致显著的增加计算量（<spanclass="math inline">\(2 × 2\rightarrow 3 ×3\)</span>，增加了2.25倍）。</p><p>在这里，我们提出了一种更高效的批处理计算方法，通过向左上方向循环移位，如<ahref="#图4"><strong>图4</strong></a>所示。</p><figure><img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03b81.png"alt="tu_4" /><figcaption aria-hidden="true">tu_4</figcaption></figure><div data-align="center"><strong>图4.对于在移位窗口分区中的自注意力的高效批处理计算方法的示意图。</strong></div><p>在这种移位后，一个批处理窗口可能由几个在特征图中不相邻的子窗口组成，因此采用了一个掩码机制来限制自注意力计算在每个子窗口内进行。通过循环移位，批处理窗口的数量保持与常规窗口划分相同，因此也是高效的。这种方法的低延迟在<ahref="#表5">表5</a>中显示。</p><p><strong>相对位置偏置</strong> 在计算自注意力时，我们遵循[49, 1, 32,33]的做法，通过在计算相似性时为每个头部添加一个相对位置偏置 <spanclass="math inline">\(B ∈ \R ^{M^2×M^2}\)</span> ：</p><p><span class="math display">\[\text{Attention(Q, K, V)} = \text {SoftMax}(QKᵀ /\sqrt  {d} + B)V,\]</span></p><p>其中 $Q, K, V ∈ <sup>{M</sup>2×d} $ 是查询、键和值矩阵；<spanclass="math inline">\(d\)</span> 是查询/键的维度，<spanclass="math inline">\(M^2\)</span>是窗口中的补丁数量。由于每个轴上的相对位置在范围<spanclass="math inline">\([-M + 1, M -1]\)</span>内，我们将一个尺寸较小的偏置矩阵 <spanclass="math inline">\(\hat{B}∈ \R^{(2M-1)×(2M-1)}\)</span>参数化，并且从 <span class="math inline">\(\hat{B}\)</span> 中取出 <spanclass="math inline">\(B\)</span> 中的值。</p><p>我们观察到相对位置偏置项明显改善了与没有该偏置项或使用绝对位置嵌入的对应模型相比的性能，如<ahref="#表4">表4</a>所示。进一步将绝对位置嵌入添加到输入中（如[20]中所示）会略微降低性能，因此在我们的实现中没有采用这种方法。</p><p>在预训练过程中学到的相对位置偏置也可以用于通过双三次插值[20,63]初始化具有不同窗口大小的模型，以进行微调。</p><h3 id="架构变体">3.3. 架构变体</h3><p>我们构建了我们的基础模型，称为Swin-B，其模型大小和计算复杂度与ViT-B/DeiT-B类似。我们还介绍了Swin-T、Swin-S和Swin-L，它们的模型大小和计算复杂度分别为基础模型的0.25×、0.5×和2×。请注意，Swin-T和Swin-S的复杂度与ResNet-50（DeiT-S）和ResNet-101相似，窗口大小默认设置为<spanclass="math inline">\(M = 7\)</span>。每个头的查询维度为<spanclass="math inline">\(d = 32\)</span>，每个MLP的扩展层为<spanclass="math inline">\(α =4\)</span>，对于所有实验，这些模型变体的架构超参数如下：</p><ul><li>Swin-T: C = 96, 层级数量 = {2, 2, 6, 2}</li><li>Swin-S: C = 96, 层级数量 = {2, 2, 18, 2}</li><li>Swin-B: C = 128, 层级数量 = {2, 2, 18, 2}</li><li>Swin-L: C = 192, 层级数量 = {2, 2, 18, 2}</li></ul><p>这里的 <span class="math inline">\(C\)</span>是第一个阶段隐藏层的通道数。模型大小、理论计算复杂度（FLOPs）以及用于ImageNet图像分类的模型变体的吞吐量详见<ahref="#表1">表1</a>。</p><h2 id="实验">4、 实验</h2><p>我们在ImageNet-1K图像分类[19]、COCO目标检测[43]和ADE20K语义分割[83]上进行了实验。接下来，我们首先将提出的SwinTransformer架构与先前的技术水平进行比较，然后对SwinTransformer的重要设计元素进行了实验验证。</p><h3 id="imagenet-1k上的图像分类">4.1. ImageNet-1K上的图像分类</h3><p><strong>设置：</strong>对于图像分类，我们在ImageNet-1K[19]上评估了提出的SwinTransformer，该数据集包含来自1,000个类别的1.28M训练图像和50K验证图像。我们报告了单个裁剪的top-1准确度。我们考虑了两种训练设置：</p><ul><li><p>常规的ImageNet-1K训练：此设置主要遵循[63]。我们使用AdamW[37]优化器进行300个epoch的训练，使用余弦衰减学习率调度器和20个epoch的线性热身。我们使用批大小为1024，初始学习率为0.001，权重衰减为0.05。在训练中，我们包括了[63]中的大多数增强和正则化策略，但不包括重复的增强[31]和EMA[45]，因为它们并不能提升性能。值得注意的是，这与[63]相反，在ViT的训练中，重复的增强对于稳定训练是至关重要的。</p></li><li><p>在ImageNet-22K上进行预训练，然后在ImageNet-1K上进行微调：我们还在更大的ImageNet-22K数据集上进行预训练，该数据集包含了1420万张图像和22,000个类别。我们使用AdamW优化器进行90个epoch的训练，使用线性衰减学习率调度器和5个epoch的线性热身。我们使用批大小为4096，初始学习率为0.001，权重衰减为0.01。在ImageNet-1K的微调中，我们使用批大小为1024，学习率保持为<spanclass="math inline">\(10^{-5}\)</span>，权重衰减为<spanclass="math inline">\(10^{-8}\)</span>，训练模型30个epoch。</p></li></ul><p><strong>常规ImageNet-1K训练的结果。</strong> 如<ahref="#表1(a)"><strong>表1(a)</strong></a>所示，其中与其他主干网络进行了比较，包括基于Transformer和ConvNet的网络。</p><div data-align="center"><strong><a name="表1">表1.在ImageNet-1K分类任务上不同骨干网络的比较。吞吐量使用[68]的GitHub存储库和V100GPU进行测量，遵循[63]的方法。</a></strong></div><div data-align="center"><strong><a name="表1(a)">(a)使用常规的ImageNet-1K训练的模型</a></strong></div><table><thead><tr class="header"><th>方法</th><th>图像尺寸</th><th>参数数量</th><th>计算量 (FLOPs)</th><th>吞吐量 (图像/秒)</th><th>ImageNet Top-1 准确率</th></tr></thead><tbody><tr class="odd"><td>RegNetY-4G [48]</td><td>224x224</td><td>21M</td><td>4.0G</td><td>1156.7</td><td>80.0</td></tr><tr class="even"><td>RegNetY-8G [48]</td><td>224x224</td><td>39M</td><td>8.0G</td><td>591.6</td><td>81.7</td></tr><tr class="odd"><td>RegNetY-16G [48]</td><td>224x224</td><td>84M</td><td>16.0G</td><td>334.7</td><td>82.9</td></tr><tr class="even"><td>EffNet-B3 [58]</td><td>300x300</td><td>12M</td><td>1.8G</td><td>732.1</td><td>81.6</td></tr><tr class="odd"><td>EffNet-B4 [58]</td><td>380x380</td><td>19M</td><td>4.2G</td><td>349.4</td><td>82.9</td></tr><tr class="even"><td>EffNet-B5 [58]</td><td>456x456</td><td>30M</td><td>9.9G</td><td>169.1</td><td>83.6</td></tr><tr class="odd"><td>EffNet-B6 [58]</td><td>528x528</td><td>43M</td><td>19.0G</td><td>96.9</td><td>84.0</td></tr><tr class="even"><td>EffNet-B7 [58]</td><td>600x600</td><td>66M</td><td>37.0G</td><td>55.1</td><td>84.3</td></tr><tr class="odd"><td>ViT-B/16 [20]</td><td>384x384</td><td>86M</td><td>55.4G</td><td>85.9</td><td>77.9</td></tr><tr class="even"><td>ViT-L/16 [20]</td><td>384x384</td><td>307M</td><td>190.7G</td><td>27.3</td><td>76.5</td></tr><tr class="odd"><td>DeiT-S [63]</td><td>224x224</td><td>22M</td><td>4.6G</td><td>940.4</td><td>79.8</td></tr><tr class="even"><td>DeiT-B [63]</td><td>224x224</td><td>86M</td><td>17.5G</td><td>292.3</td><td>81.8</td></tr><tr class="odd"><td>DeiT-B [63]</td><td>384x384</td><td>86M</td><td>55.4G</td><td>85.9</td><td>83.1</td></tr><tr class="even"><td>Swin-T</td><td>224x224</td><td>29M</td><td>4.5G</td><td>755.2</td><td>81.3</td></tr><tr class="odd"><td>Swin-S</td><td>224x224</td><td>50M</td><td>8.7G</td><td>436.9</td><td>83.0</td></tr><tr class="even"><td>Swin-B</td><td>224x224</td><td>88M</td><td>15.4G</td><td>278.1</td><td>83.5</td></tr><tr class="odd"><td>Swin-B</td><td>384x384</td><td>88M</td><td>47.0G</td><td>84.7</td><td>84.5</td></tr></tbody></table><div data-align="center"><strong><a name="表1(b)">(b) 使用ImageNet-22K预训练的模型</a></strong></div><table><thead><tr class="header"><th>方法</th><th>图像尺寸</th><th>参数数量</th><th>计算量 (FLOPs)</th><th>吞吐量 (图像/秒)</th><th>ImageNet Top-1 准确率</th></tr></thead><tbody><tr class="odd"><td>R-101x3 [38]</td><td>384x384</td><td>388M</td><td>204.6G</td><td>-</td><td>84.4</td></tr><tr class="even"><td>R-152x4 [38]</td><td>480x480</td><td>937M</td><td>840.5G</td><td>-</td><td>85.4</td></tr><tr class="odd"><td>ViT-B/16 [20]</td><td>384x384</td><td>86M</td><td>55.4G</td><td>85.9</td><td>84.0</td></tr><tr class="even"><td>ViT-L/16 [20]</td><td>384x384</td><td>307M</td><td>190.7G</td><td>27.3</td><td>85.2</td></tr><tr class="odd"><td>Swin-B</td><td>224x224</td><td>88M</td><td>15.4G</td><td>278.1</td><td>85.2</td></tr><tr class="even"><td>Swin-B</td><td>384x384</td><td>88M</td><td>47.0G</td><td>84.7</td><td>86.4</td></tr><tr class="odd"><td>Swin-L</td><td>384x384</td><td>197M</td><td>103.9G</td><td>42.1</td><td>87.3</td></tr></tbody></table><hr /><p>与先前的最先进的基于Transformer的架构DeiT [63]相比，SwinTransformer明显超过了复杂度相似的DeiT架构：使用224x224的输入，Swin-T（81.3%）比DeiT-S（79.8%）提高了+1.5%；使用224x224/384x384的输入，Swin-B（83.3%/84.5%）比DeiT-B（81.8%/83.1%）提高了+1.5%/1.4%。</p><p>与最先进的ConvNets，如RegNet [48]和EfficientNet [58]相比，SwinTransformer实现了稍微更好的速度-准确度权衡。值得注意的是，尽管RegNet[48]和EfficientNet [58]是通过彻底的架构搜索得到的，但提出的SwinTransformer是从标准的Transformer进行了改进，具有进一步提升的潜力。</p><p><strong>使用ImageNet-22K预训练的结果</strong>我们还对容量更大的Swin-B和Swin-L进行了ImageNet-22K的预训练。在ImageNet-1K图像分类上进行微调的结果如表1(b)所示。对于Swin-B，ImageNet-22K的预训练带来了1.8%~1.9%的提升，相比于从头开始在ImageNet-1K上训练。与以前在ImageNet-22K预训练的最佳结果相比，我们的模型在速度-准确度权衡方面取得了显著的改进：Swin-B获得了86.4%的top-1准确度，比具有类似推理吞吐量（84.7比85.9图像/秒）和稍低FLOPs（47.0G比55.4G）的ViT高2.4%。更大的Swin-L模型实现了87.3%的top-1准确度，比Swin-B模型好0.9%。</p><h3 id="在coco上进行目标检测">4.2. 在COCO上进行目标检测</h3><p><strong>设置</strong>：我们在COCO2017数据集上进行目标检测和实例分割实验，该数据集包含了118K张训练图片，5K张验证图片和20K张测试图片。我们在验证集上进行了消融研究，并在测试集上进行了系统级别的比较。</p><p>对于消融研究，我们考虑了四种典型的目标检测框架：级联MaskR-CNN、ATSS、RepPoints v2和SparseRCNN。对于这四种框架，我们使用了相同的设置：多尺度训练（将输入调整大小，使较短的一侧在480到800之间，较长的一侧最多为1333）、AdamW优化器（初始学习率为0.0001，权重衰减为0.05，批量大小为16）和3x调度（36个epochs）。</p><p>对于系统级别的比较，我们采用了改进版HTC（标记为HTC++），其中包括instaboost、更强大的多尺度训练、6x调度、soft-NMS和ImageNet-22K预训练模型作为初始化。</p><p>我们将我们的SwinTransformer与标准的ConvNets（如ResNe(X)t）和先前的Transformer网络（如DeiT）进行了比较。比较时，只更改了主干网络，其他设置保持不变。值得注意的是，由于SwinTransformer和ResNe(X)t具有分层特征图，因此它们可以直接应用于上述所有框架。而DeiT只产生单一分辨率的特征图，无法直接应用。为了公平比较，我们按照[81]的方法使用反卷积层为DeiT构建分层特征图。</p><p><strong>与ResNe(X)t的比较：</strong> <ahref="#表2(a)"><strong>表2(a)</strong></a>列出了Swin-T和ResNet-50在四个目标检测框架上的结果。我们的Swin-T架构在模型大小、FLOPs和延迟略大的情况下，带来了稳定的+3.4∼4.2的boxAP增益。</p><p><strong><a href="#表2(b)">表2(b)</a></strong>比较了使用Cascade MaskR-CNN时Swin Transformer和不同模型容量的ResNe(X)t。SwinTransformer实现了51.9的box AP和45.0的maskAP的高检测精度，分别比ResNeXt101-64x4d高出+3.6和+3.3，后者具有相似的模型大小、FLOPs和延迟。</p><p>在改进的HTC框架的更高基线上，实现了52.3的box AP和46.0的mask AP，SwinTransformer的增益也很高，分别为+4.1的box AP和+3.1的mask AP（<strong>见<ahref="#表2(c)">表2(c)</a></strong>）。</p><div data-align="center"><strong><a name="表2">表2. 在COCO目标检测和实例分割任务上的结果。†表示使用了额外的反卷积层来产生分层特征图。*表示使用了多尺度测试。</a></strong></div><div data-align="center"><strong><a name="表2(a)">(a) 不同的框架</a></strong></div><table><thead><tr class="header"><th>方法</th><th>骨干网络</th><th>APbox</th><th>APbox50</th><th>APbox75</th><th>参数数量</th><th>FLOPs</th><th>FPS</th></tr></thead><tbody><tr class="odd"><td>Cascade Mask R-CNN</td><td>R-50</td><td>46.3</td><td>64.3</td><td>50.5</td><td>82M</td><td>739G</td><td>18.0</td></tr><tr class="even"><td>Swin-T</td><td>-</td><td>50.5</td><td>69.3</td><td>54.9</td><td>86M</td><td>745G</td><td>15.3</td></tr><tr class="odd"><td>ATSS</td><td>R-50</td><td>43.5</td><td>61.9</td><td>47.0</td><td>32M</td><td>205G</td><td>28.3</td></tr><tr class="even"><td>Swin-T</td><td>-</td><td>47.2</td><td>66.5</td><td>51.3</td><td>36M</td><td>215G</td><td>22.3</td></tr><tr class="odd"><td>RepPointsV2</td><td>R-50</td><td>46.5</td><td>64.6</td><td>50.3</td><td>42M</td><td>274G</td><td>13.6</td></tr><tr class="even"><td>Swin-T</td><td>-</td><td>50.0</td><td>68.5</td><td>54.2</td><td>45M</td><td>283G</td><td>12.0</td></tr><tr class="odd"><td>Sparse R-CNN</td><td>R-50</td><td>44.5</td><td>63.4</td><td>48.2</td><td>106M</td><td>166G</td><td>21.0</td></tr><tr class="even"><td>Swin-T</td><td>-</td><td>47.9</td><td>67.3</td><td>52.3</td><td>110M</td><td>172G</td><td>18.4</td></tr></tbody></table><div data-align="center"><strong><a name="表2(b)">(b) 不同的骨干网络，使用Cascade MaskR-CNN</a></strong></div><table><thead><tr class="header"><th>骨干网络</th><th>APbox</th><th>APbox50</th><th>APbox75</th><th>APmask</th><th>APmask50</th><th>APmask75</th><th>参数数量</th><th>FLOPs</th><th>FPS</th></tr></thead><tbody><tr class="odd"><td>DeiT-S</td><td>48.0</td><td>67.2</td><td>51.7</td><td>41.4</td><td>64.2</td><td>44.3</td><td>80M</td><td>889G</td><td>10.4</td></tr><tr class="even"><td>R50</td><td>46.3</td><td>64.3</td><td>50.5</td><td>40.1</td><td>61.7</td><td>43.4</td><td>82M</td><td>739G</td><td>18.0</td></tr><tr class="odd"><td>Swin-T</td><td>50.5</td><td>69.3</td><td>54.9</td><td>43.7</td><td>66.6</td><td>47.1</td><td>86M</td><td>745G</td><td>15.3</td></tr><tr class="even"><td>X101-32</td><td>48.1</td><td>66.5</td><td>52.4</td><td>41.6</td><td>63.9</td><td>45.2</td><td>101M</td><td>819G</td><td>12.8</td></tr><tr class="odd"><td>Swin-S</td><td>51.8</td><td>70.4</td><td>56.3</td><td>44.7</td><td>67.9</td><td>48.5</td><td>107M</td><td>838G</td><td>12.0</td></tr><tr class="even"><td>X101-64</td><td>48.3</td><td>66.4</td><td>52.3</td><td>41.7</td><td>64.0</td><td>45.1</td><td>140M</td><td>972G</td><td>10.4</td></tr><tr class="odd"><td>Swin-B</td><td>51.9</td><td>70.9</td><td>56.5</td><td>45.0</td><td>68.4</td><td>48.7</td><td>145M</td><td>982G</td><td>11.6</td></tr></tbody></table><div data-align="center"><strong><a name="表2(c)">(c) 系统级别的比较</a></strong></div><table style="width:100%;"><thead><tr class="header"><th>方法</th><th>mini-val</th><th>test-dev</th><th>参数数量</th><th>FLOPs</th><th>APbox</th><th>APmask</th><th>APbox</th><th>APmask</th></tr></thead><tbody><tr class="odd"><td>RepPointsV2</td><td>*</td><td>*</td><td>185M</td><td>1440G</td><td>55.9</td><td>47.2</td><td>56.0</td><td>47.4</td></tr><tr class="even"><td>Copy-paste</td><td>55.9</td><td>47.2</td><td>185M</td><td>1440G</td><td>56.0</td><td>47.4</td><td>-</td><td>-</td></tr><tr class="odd"><td>Swin-B (HTC++)</td><td>56.4</td><td>49.1</td><td>160M</td><td>1043G</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>Swin-L (HTC++)</td><td>57.1</td><td>49.5</td><td>284M</td><td>1470G</td><td>57.7</td><td>50.2</td><td>58.7</td><td>51.1</td></tr><tr class="odd"><td>Swin-L (HTC++)*</td><td>58.0</td><td>50.4</td><td>284M</td><td>-</td><td>58.7</td><td>51.1</td><td>-</td><td>-</td></tr></tbody></table><p>关于推理速度，虽然ResNe(X)t是通过高度优化的Cudnn函数构建的，但我们的架构是使用内置的PyTorch函数实现的，并非所有函数都经过了良好的优化。深度优化超出了本文的范围。</p><p><strong>与DeiT的比较：</strong> 使用Cascade MaskR-CNN框架，DeiT-S的性能如<ahref="#表2(b)"><strong>表2(b)</strong></a>所示。Swin-T的结果比DeiT-S高出+2.5的boxAP和+2.3的mask AP，模型大小相似（86M对比80M），推理速度显著更高（15.3FPS对比10.4FPS）。DeiT的推理速度较低主要是因为其对输入图像大小的复杂度为二次方。</p><p><strong>与之前的最先进模型的比较：</strong><ahref="#表2(c)"><strong>表2(c)</strong></a>将我们的最佳结果与之前的最先进模型进行了比较。我们的最佳模型在COCO测试集（test-dev）上实现了58.7的boxAP和51.1的mask AP，比先前的最佳结果分别高出+2.7的box AP（Copy-paste[26]，不使用外部数据）和+2.6的mask AP（DetectoRS [46]）。</p><p><strong>语义分割在ADE20K数据集上的实验设置：</strong> ADE20K [83]是一个广泛使用的语义分割数据集，涵盖了150个语义类别。总共有2.5万张图像，其中2万张用于训练，2千张用于验证，另外3千张用于测试。我们在mmseg[16]中使用UperNet作为基本框架，因为它具有较高的效率。更多细节将在附录中提供。</p><p><strong>结果：</strong><ahref="#表3"><strong>表格3</strong></a>列出了不同方法/骨干网络组合的mIoU、模型大小（#参数）、FLOPs和FPS。</p><div data-align="center"><strong><a name="表3">表3. ADE20K语义分割的结果（在验证集和测试集上）。†表示使用了额外的反卷积层来产生分层特征图。 ‡ 表示该模型在 ImageNet-22K上进行了预训练。</a></strong></div><table><thead><tr class="header"><th>方法</th><th>主干网络</th><th>mIoU (val)</th><th>mIoU (test)</th><th>参数数量</th><th>FLOPs</th><th>FPS</th></tr></thead><tbody><tr class="odd"><td>DANet [23]</td><td>ResNet-101</td><td>45.2</td><td>-</td><td>69M</td><td>1119G</td><td>15.2</td></tr><tr class="even"><td>DLab.v3+ [11]</td><td>ResNet-101</td><td>44.1</td><td>-</td><td>63M</td><td>1021G</td><td>16.0</td></tr><tr class="odd"><td>ACNet [24]</td><td>ResNet-101</td><td>45.9</td><td>38.5</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>DNL [71]</td><td>ResNet-101</td><td>46.0</td><td>56.2</td><td>69M</td><td>1249G</td><td>14.8</td></tr><tr class="odd"><td>OCRNet [73]</td><td>ResNet-101</td><td>45.3</td><td>56.0</td><td>56M</td><td>923G</td><td>19.3</td></tr><tr class="even"><td>UperNet [69]</td><td>ResNet-101</td><td>44.9</td><td>-</td><td>86M</td><td>1029G</td><td>20.1</td></tr><tr class="odd"><td>OCRNet [73]</td><td>HRNet-w48</td><td>45.7</td><td>-</td><td>71M</td><td>664G</td><td>12.5</td></tr><tr class="even"><td>DLab.v3+ [11]</td><td>ResNeSt-101</td><td>46.9</td><td>55.1</td><td>66M</td><td>1051G</td><td>11.9</td></tr><tr class="odd"><td>DLab.v3+ [11]</td><td>ResNeSt-200</td><td>48.4</td><td>-</td><td>88M</td><td>1381G</td><td>8.1</td></tr><tr class="even"><td>SETR [81]</td><td>T-Large‡</td><td>50.3</td><td>61.7</td><td>308M</td><td>-</td><td>-</td></tr><tr class="odd"><td>UperNet</td><td>DeiT-S†</td><td>44.0</td><td>-</td><td>52M</td><td>1099G</td><td>16.2</td></tr><tr class="even"><td>UperNet</td><td>Swin-T</td><td>46.1</td><td>-</td><td>60M</td><td>945G</td><td>18.5</td></tr><tr class="odd"><td>UperNet</td><td>Swin-S</td><td>49.3</td><td>-</td><td>81M</td><td>1038G</td><td>15.2</td></tr><tr class="even"><td>UperNet</td><td>Swin-B‡</td><td>51.6</td><td>-</td><td>121M</td><td>1841G</td><td>8.7</td></tr><tr class="odd"><td>UperNet</td><td>Swin-L‡</td><td><strong>53.5</strong></td><td><strong>62.8</strong></td><td>234M</td><td>3230G</td><td>6.2</td></tr></tbody></table><p>从这些结果可以看出，与计算成本相似的DeiT-S相比，Swin-S的mIoU要高出5.3（49.3比44.0）。它也比ResNet-101高出4.4mIoU，比ResNeSt-101 [78] 高出2.4mIoU。我们的经过ImageNet-22K预训练的Swin-L模型在验证集上达到了53.5mIoU，超过了之前最好的模型，其mIoU高出3.2（SETR [81]的mIoU为50.3，但其模型规模更大）。</p><h3 id="ablation-study">4.4. Ablation Study</h3><p>在这一部分中，我们对所提出的SwinTransformer中的重要设计元素进行了剖析，使用了ImageNet-1K图像分类、COCO目标检测的级联掩蔽R-CNN，以及ADE20K语义分割的UperNet。</p><p><strong>Shifted Windows</strong> <ahref="#表4"><strong>表4</strong></a>报告了在三个任务上对移位窗口方法进行的剖析。</p><div data-align="center"><strong><a name="表4">表格 4.偏移窗口方法和不同位置嵌入方法的消融研究，使用 Swin-T架构在三个基准上进行，不做偏移：所有自注意力模块采用常规窗口划分，不做偏移；abs.pos.: ViT 的绝对位置嵌入项；rel. pos.:默认设置下的相对位置偏置项（参见公式（4））；app.:公式（4）中的第一个缩放的点积项。</a></strong></div><table><thead><tr class="header"><th></th><th>ImageNet</th><th>ImageNet</th><th>COCO</th><th>COCO</th><th>ADE20K</th></tr></thead><tbody><tr class="odd"><td></td><td>top-1</td><td>top-5</td><td><span class="math inline">\(AP^{box}\)</span></td><td><span class="math inline">\(AP^{mask}\)</span></td><td>mIoU</td></tr><tr class="even"><td>无偏移窗口</td><td>80.2</td><td>95.1</td><td>47.7</td><td>41.5</td><td>43.3</td></tr><tr class="odd"><td>偏移窗口</td><td>81.3</td><td>95.6</td><td>50.5</td><td>43.7</td><td>46.1</td></tr><tr class="even"><td>无位置编码</td><td>80.1</td><td>94.9</td><td>49.2</td><td>42.6</td><td>43.8</td></tr><tr class="odd"><td>绝对位置编码</td><td>80.5</td><td>95.2</td><td>49.0</td><td>42.4</td><td>43.2</td></tr><tr class="even"><td>绝对+相对位置编码</td><td>81.3</td><td>95.6</td><td>50.2</td><td>43.4</td><td>44.0</td></tr><tr class="odd"><td>相对位置编码（无应用）</td><td>79.3</td><td>94.7</td><td>48.2</td><td>41.9</td><td>44.1</td></tr><tr class="even"><td>相对位置编码</td><td>81.3</td><td>95.6</td><td>50.5</td><td>43.7</td><td>46.1</td></tr></tbody></table><p>使用移位窗口划分的Swin-T优于在每个阶段都建立在单窗口划分的对应模型，对于ImageNet-1K，top-1准确度提高了+1.1%，对于COCO，boxAP/mask AP提高了+2.8/+2.2，对于ADE20K，mIoU提高了+2.8。</p><p><strong>相对位置偏置</strong> <a href="#表4"><strong>表4</strong></a>还报告了相对位置偏置的剖析。相对位置偏置对于所有三个任务都是有效的，相对于没有位置编码和具有绝对位置嵌入的模型，它们分别提高了+3.3/+3.2box AP，+2.3/+2.9 mask AP和+2.3/+2.9mIoU。这表明了相对位置偏置的有效性。同时值得注意的是，虽然包含绝对位置嵌入可以提高图像分类的准确度（+0.4%），但会降低目标检测和语义分割的准确度（COCO的-0.2box/mask AP，ADE20K的-0.6 mIoU）。</p><p><strong>不同自注意方法</strong> <ahref="#表5"><strong>表5</strong></a>比较了不同自注意计算方法的实际速度以及实现。</p><div data-align="center"><strong><a name="表5">表格5. 在V100GPU上不同自注意力计算方法和实现的实际速度。</a></strong></div><table><thead><tr class="header"><th>方法</th><th>MSA in a stage (ms)S1</th><th>S2</th><th>S3</th><th>S4</th><th>Arch. (FPS)T</th><th>S</th><th>B</th></tr></thead><tbody><tr class="odd"><td>滑动窗口 (朴素)</td><td>122.5</td><td>38.3</td><td>12.1</td><td>7.6</td><td>183</td><td>109</td><td>77</td></tr><tr class="even"><td>滑动窗口 (内核)</td><td>7.6</td><td>4.7</td><td>2.7</td><td>1.8</td><td>488</td><td>283</td><td>187</td></tr><tr class="odd"><td>Performer [14]</td><td>4.8</td><td>2.8</td><td>1.8</td><td>1.5</td><td>638</td><td>370</td><td>241</td></tr><tr class="even"><td>窗口 (无偏移)</td><td>2.8</td><td>1.7</td><td>1.2</td><td>0.9</td><td>770</td><td>444</td><td>280</td></tr><tr class="odd"><td>偏移窗口 (填充)</td><td>3.3</td><td>2.3</td><td>1.9</td><td>2.2</td><td>670</td><td>371</td><td>236</td></tr><tr class="even"><td>偏移窗口 (循环)</td><td>3.0</td><td>1.9</td><td>1.3</td><td>1.0</td><td>755</td><td>437</td><td>278</td></tr></tbody></table><p>我们的循环实现比朴素的填充更具硬件效率，特别是对于更深的阶段。总体而言，它使Swin-T、Swin-S和Swin-B分别提速了13%、18%和18%。</p><p>在四个网络阶段上，基于提议的移位窗口方法构建的自注意模块，在朴素/内核实现上比基于滑动窗口的模块更高效，分别为40.8×/2.5×，20.2×/2.5×，9.3×/2.1×和7.6×/1.8×。总的来说，基于移位窗口的SwinTransformer架构在Swin-T、Swin-S和Swin-B上比基于滑动窗口的变体分别快4.1/1.5、4.0/1.5和3.6/1.5倍。表6比较了它们在三个任务上的准确性，表明它们在视觉建模方面具有相似的准确性。</p><p>与Performer[14]相比，后者是最快的Transformer架构之一（参见[60]），所提出的基于移位窗口的自注意计算和整体的SwinTransformer架构略快（见<ahref="#表5">表5</a>），同时使用Swin-T在ImageNet-1K上比Performer提高了+2.3%的top-1准确度（见<ahref="#表6">表6</a>）。</p><div data-align="center"><strong><a name="表6">表格6.在三个基准测试中，使用不同自注意力计算方法的SwinTransformer的准确度。</a></strong></div><table style="width:100%;"><thead><tr class="header"><th></th><th></th><th>ImageNet</th><th>ImageNet</th><th>COCO</th><th>COCO</th><th>ADE20K</th></tr></thead><tbody><tr class="odd"><td></td><td>Backbone</td><td>top-1</td><td>top-5</td><td><span class="math inline">\(AP^{box}\)</span></td><td><span class="math inline">\(AP^{mask}\)</span></td><td>mIoU</td></tr><tr class="even"><td>滑动窗口</td><td>Swin-T</td><td>81.4</td><td>95.6</td><td>50.2</td><td>43.5</td><td>45.8</td></tr><tr class="odd"><td>表演家 [14]</td><td>Swin-T</td><td>79.0</td><td>94.2</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>移动窗口</td><td>Swin-T</td><td>81.3</td><td>95.6</td><td>50.5</td><td>43.7</td><td>46.1</td></tr></tbody></table><h2 id="结论">5、 结论</h2><p>本文介绍了SwinTransformer，这是一种新的视觉Transformer模型，它生成了一个分层的特征表示，并且相对于输入图像大小具有线性的计算复杂度。SwinTransformer在COCO目标检测和ADE20K语义分割任务上取得了最先进的性能，明显超越了先前的最佳方法。我们希望SwinTransformer在各种视觉问题上的强大性能能够鼓励对视觉和语言信号进行统一建模。</p><p>作为SwinTransformer的关键组成部分，基于移位窗口的自注意力机制在视觉问题上表现出色且高效，我们期待着在自然语言处理领域中进一步研究其应用。</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>论文阅读</tag>
      
      <tag>Swin Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日水论文-停更一天</title>
    <link href="/2024/04/15/%E4%BB%8A%E6%97%A5%E6%B0%B4%E8%AE%BA%E6%96%87-%E5%81%9C%E6%9B%B4%E4%B8%80%E5%A4%A9/"/>
    <url>/2024/04/15/%E4%BB%8A%E6%97%A5%E6%B0%B4%E8%AE%BA%E6%96%87-%E5%81%9C%E6%9B%B4%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="今天改论文-停更一天">今天改论文-停更一天</h1><span id="more"></span><h1 id="往期图片分享">往期图片分享</h1><p><imgsrc="https://pic.imgdb.cn/item/661b828768eb935713d67a33.png" /></p><p><imgsrc="https://pic.imgdb.cn/item/661b813268eb935713d5b4c6.png" /></p><p><imgsrc="https://pic.imgdb.cn/item/661b813268eb935713d5b508.png" /></p><p><imgsrc="https://pic.imgdb.cn/item/661b828968eb935713d67ace.png" /></p><p><imgsrc="https://pic.imgdb.cn/item/661b82f868eb935713d6b96a.png" /></p><p><img src="https://s21.ax1x.com/2024/04/11/pFXmRYV.jpg" /></p><p><img src="https://s21.ax1x.com/2024/04/11/pFXm2F0.jpg" /></p><p><img src="https://s21.ax1x.com/2024/04/10/pFOcMcT.jpg" /></p><p><img src="https://s21.ax1x.com/2024/04/10/pFOcu90.jpg" /></p><p><img src="https://s21.ax1x.com/2024/04/10/pFOcmhq.jpg" /></p><p><img src="https://s21.ax1x.com/2024/04/08/pFLJe5d.png" /></p><p><img src="https://s21.ax1x.com/2024/04/07/pFqfvBF.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>小记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>说明</tag>
      
      <tag>图片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理-直方图分析</title>
    <link href="/2024/04/14/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%88%86%E6%9E%90/"/>
    <url>/2024/04/14/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="图像直方图分析及实验">图像直方图分析及实验</h1><span id="more"></span><p>1.1 使用 OpenCV 统计直方图</p><p>函数 cv2.calcHist 可以帮助我们统计一幅图像的直方图。我们一起来熟悉一下这个函数和它的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cv2.calcHist(images, channels, mask, histSize, ranges, hist, accumulate)<br></code></pre></td></tr></table></figure><ul><li><p><strong>images</strong>：原图像（图像格式为 uint8 或float32）。当传入函数时应该 用中括号 [] 括起来，例如：[img]。</p></li><li><p><strong>channels</strong>：同样需要用中括号括起来，它会告诉函数我们要统计那幅图像的直方图。如果输入图像是灰度图，它的值就是 [0]；如果是彩色图像的话，传入的参数可以是 [0]，[1]，[2] 它们分别对应着通道B，G，R。</p></li><li><p><strong>mask</strong>: 掩模图像。要统计整幅图像的直方图就把它设为None。但是如果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并使用它。（后边有例子）</p></li><li><p><strong>histSize</strong>：BIN的数目。也应该用中括号括起来，例如：[256]。</p></li><li><p><strong>ranges:</strong> 像素值范围，通常为 [0，256]</p></li><li><p><strong>hist</strong>：是一个 256x1的数组作为返回值，每一个值代表了与次灰度值对应的像素点数目。</p></li><li><p><strong>accumulate</strong>：是一个布尔值，用来表示直方图是否叠加。</p></li></ul><hr /><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br> <br>img1 = cv2.imread(<span class="hljs-string">&#x27;28.png&#x27;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 别忘了中括号 [img],[0],None,[256],[0,256]，只有 mask 没有中括号</span><br>hist1 = cv2.calcHist([img1], [<span class="hljs-number">0</span>], <span class="hljs-literal">None</span>, [<span class="hljs-number">256</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br> <br>img2 = cv2.imread(<span class="hljs-string">&#x27;28.png&#x27;</span>)<br>color = (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-keyword">for</span> i, col <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(color):<br>    histr = cv2.calcHist([img2], [i], <span class="hljs-literal">None</span>, [<span class="hljs-number">256</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br>    plt.subplot(<span class="hljs-number">224</span>), plt.plot(histr, color=col),<br>    plt.xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]), plt.title(<span class="hljs-string">&#x27;Histogram&#x27;</span>)<br>    <br> <br>plt.subplot(<span class="hljs-number">221</span>), plt.imshow(img1, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;Image1&#x27;</span>)<br>plt.subplot(<span class="hljs-number">222</span>), plt.hist(img1.ravel(), <span class="hljs-number">256</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]),<br>plt.title(<span class="hljs-string">&#x27;Histogram&#x27;</span>), plt.xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br>plt.subplot(<span class="hljs-number">223</span>), plt.imshow(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)), plt.title(<span class="hljs-string">&#x27;Image2&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><figure><img src="https://pic.imgdb.cn/item/661b82f868eb935713d6b96a.png"alt="原图" /><figcaption aria-hidden="true">原图</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/661b848968eb935713d7a6af.png"alt="直方图分析分析" /><figcaption aria-hidden="true">直方图分析分析</figcaption></figure><p><strong>对蓝色变量累积分布图：</strong></p><figure><img src="https://pic.imgdb.cn/item/661b854d68eb935713d80912.png"alt="B变量累积分布图" /><figcaption aria-hidden="true">B变量累积分布图</figcaption></figure><h1 id="直方图均衡">直方图均衡</h1><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>img = cv2.imread(<span class="hljs-string">&#x27;28.png&#x27;</span>,<span class="hljs-number">0</span>)<br>cv2.imshow(<span class="hljs-string">&#x27;img1&#x27;</span>,img)<br><br><span class="hljs-comment"># 直方图均衡</span><br>equ = cv2.equalizeHist(img)<br>res = np.hstack((img,equ))<br><span class="hljs-comment">#stacking images side-by-side</span><br>cv2.imshow(<span class="hljs-string">&#x27;img2&#x27;</span>,res)<br>cv2.waitKey()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p><strong>直方图均衡之前</strong></p><p><imgsrc="https://pic.imgdb.cn/item/661b854d68eb935713d80912.png" /></p><p><strong>直方图均衡后</strong></p><p><imgsrc="https://pic.imgdb.cn/item/661b888668eb935713dc212a.png" /></p><h1 id="总结">总结</h1><p>本实验对图像的直方图进行分析，并进行图片的直方图均衡、直方图分析，了解直方图均衡方法，明白直方图均衡可以很好的均衡图片的像素分布。</p><p>当然本实验也有不足，没能很好地展现直方图均衡前后图片的变化。根据书上的学习可以预先知道，直方图分析可以使得灰度图片变得更清晰可读。</p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>图像</tag>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记</title>
    <link href="/2024/04/13/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/04/13/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="python-平时常用用法">python 平时常用用法</h1><p>待完善。。。</p><span id="more"></span><ul><li><p>字典赋值：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dictname [key] = value<br></code></pre></td></tr></table></figure></p></li><li><p>字符串添加元素：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.join([str1,str2])<br></code></pre></td></tr></table></figure></p></li><li><p>删除字符串中非字母和数字元素：</p><ul><li><p>方法一：isalnum()方法</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">string_value = <span class="hljs-string">&quot;alphanumeric@123__&quot;</span><br>s = <span class="hljs-string">&#x27;&#x27;</span>.join(ch <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> string_value <span class="hljs-keyword">if</span> ch.isalnum())<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure></p><p><strong>输出：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">alphanumeric123<br></code></pre></td></tr></table></figure></p></li><li><p>方法二：使用正则表达式</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>string_value = <span class="hljs-string">&quot;alphanumeric@123__&quot;</span><br>s=re.sub(<span class="hljs-string">r&#x27;[\W_]+&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, string_value)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure></p><p><strong>输出：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">alphanumeric123<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>字符串转大小写：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;www.runoob.com&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.upper())          <span class="hljs-comment"># 把所有字符中的小写字母转换成大写字母</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.lower())          <span class="hljs-comment"># 把所有字符中的大写字母转换成小写字母</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.capitalize())     <span class="hljs-comment"># 把第一个字母转化为大写字母，其余小写</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.title())          <span class="hljs-comment"># 把每个单词的第一个字母转化为大写，其余小写</span><br></code></pre></td></tr></table></figure></p><p><strong>输出：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">WWW.RUNOOB.COM<br>www.runoob.com<br>Www.runoob.com<br>Www.Runoob.Com<br></code></pre></td></tr></table></figure></p></li><li><p>字符串删除字符：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;abc:cba&#x27;</span><br>s1 = s[:<span class="hljs-number">3</span>] + s[-<span class="hljs-number">3</span>:]<br><span class="hljs-built_in">print</span>(s1)<br></code></pre></td></tr></table></figure></p><p><strong>输出：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">abccba<br></code></pre></td></tr></table></figure></p></li><li><p>初始化字典</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化字典 dic ，且所有 key 的初始 value 都为 0</span><br>dic = defaultdict(<span class="hljs-built_in">int</span>)<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>    dic[c] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:<br>        dic[c] -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> dic.values():<br>            <span class="hljs-keyword">if</span> val != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></p></li><li><p>排列组合</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># combinations(iterable, r) 函数接受一个可迭代对象 iterable 和一个整数 r，</span><br><span class="hljs-comment"># 返回一个包含所有长度为 r 的组合的可迭代对象。</span><br><span class="hljs-comment"># 组合是不考虑顺序的子集。</span><br><br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations<br><br><span class="hljs-comment"># 语法：combinations(iterable, r)</span><br><br><span class="hljs-comment"># 示例</span><br>iterable = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>r = <span class="hljs-number">2</span><br>result = combinations(iterable, r)<br><br><span class="hljs-comment"># 注意：combinations() 返回的是一个迭代器，需要将其转换为列表或使用循环访问元素</span><br>combinations_list = <span class="hljs-built_in">list</span>(result)<br><span class="hljs-built_in">print</span>(combinations_list)<br></code></pre></td></tr></table></figure></p></li></ul><h1 id="python内置函数">python内置函数</h1><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;"></th><th style="text-align: left;">内置函数</th><th style="text-align: left;"></th><th style="text-align: left;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-abs.html">abs()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-divmod.html">divmod()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-input.html">input()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-open.html">open()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-staticmethod.html">staticmethod()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-all.html">all()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-enumerate.html">enumerate()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-int.html">int()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-ord.html">ord()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-str.html">str()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-any.html">any()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-eval.html">eval()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-isinstance.html">isinstance()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-pow.html">pow()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-sum.html">sum()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-basestring.html">basestring()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-execfile.html">execfile()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-issubclass.html">issubclass()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-print.html">print()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-super.html">super()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-bin.html">bin()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-file.html">file()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-iter.html">iter()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-property.html">property()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-tuple-tuple.html">tuple()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-bool.html">bool()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-filter.html">filter()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-string-len.html">len()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-range.html">range()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-type.html">type()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-bytearray.html">bytearray()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-float.html">float()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-list-list.html">list()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-raw_input.html">raw_input()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-unichr.html">unichr()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-callable.html">callable()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-string-format.html">format()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-locals.html">locals()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-reduce.html">reduce()</a></td><td style="text-align: left;">unicode()</td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-chr.html">chr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-frozenset.html">frozenset()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-long.html">long()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-reload.html">reload()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-vars.html">vars()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-classmethod.html">classmethod()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-getattr.html">getattr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-map.html">map()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-repr.html">repr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-xrange.html">xrange()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-cmp.html">cmp()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-globals.html">globals()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-max.html">max()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-list-reverse.html">reverse()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-zip.html">zip()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-compile.html">compile()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-hasattr.html">hasattr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-memoryview.html">memoryview()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-round.html">round()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-__import__.html"><strong>import</strong>()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-complex.html">complex()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-hash.html">hash()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-min.html">min()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-set.html">set()</a></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-delattr.html">delattr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-help.html">help()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-next.html">next()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-setattr.html">setattr()</a></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-dict.html">dict()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-hex.html">hex()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python3/python-func-object.html">object()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-slice.html">slice()</a></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-dir.html">dir()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-id.html">id()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-oct.html">oct()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-sorted.html">sorted()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-exec.html">exec内置表达式</a></td></tr></tbody></table><h1 id="python-abs函数">python abs()函数</h1><h2 id="描述">描述</h2><p>abs() 函数返回数字的绝对值。</p><hr /><h3 id="语法">语法</h3><p>以下是 abs() 方法的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">( x )</span></span><br></code></pre></td></tr></table></figure><hr /><h3 id="参数">参数</h3><ul><li>x -- 数值表达式。</li></ul><hr /><h3 id="返回值">返回值</h3><p>函数返回x（数字）的绝对值。</p><hr /><h2 id="实例">实例</h2><p>以下展示了使用 abs() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;abs(-45) : &quot;</span>, <span class="hljs-built_in">abs</span>(-<span class="hljs-number">45</span>) <br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;abs(100.12) : &quot;</span>, <span class="hljs-built_in">abs</span>(<span class="hljs-number">100.12</span>) <br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;abs(119L) : &quot;</span>, <span class="hljs-built_in">abs</span>(<span class="hljs-number">119L</span>)<br></code></pre></td></tr></table></figure><p>以上实例运行后输出结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(-<span class="hljs-number">45</span>)</span></span> :  <span class="hljs-number">45</span><br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-number">100.12</span>)</span></span> :  <span class="hljs-number">100.12</span><br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-number">119</span>L)</span></span> :  <span class="hljs-number">119</span><br></code></pre></td></tr></table></figure><hr /><h1 id="python-divmod-函数">Python divmod() 函数</h1><p>python divmod()函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a %b)。</p><p>在 python 2.3 版本之前不允许处理复数。</p><h2 id="函数语法">函数语法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divmod</span><span class="hljs-params">(a, b)</span></span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>a: 数字</li><li>b: 数字</li></ul><h2 id="实例-1">实例</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">&gt;&gt;&gt;<span class="hljs-built_in">divmod</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>) <br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>&gt;&gt;&gt; <span class="hljs-built_in">divmod</span>(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>) <br>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>) <br>&gt;&gt;&gt; <span class="hljs-built_in">divmod</span>(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>j,<span class="hljs-number">1</span>+<span class="hljs-number">0.5</span>j) <br>((<span class="hljs-number">1</span>+<span class="hljs-number">0</span>j), <span class="hljs-number">1.5</span>j)<br></code></pre></td></tr></table></figure><hr /><h1 id="python-staticmethod-函数">Python staticmethod() 函数</h1><p>python staticmethod 返回函数的静态方法。</p><p>该方法不强制要求传递参数，如下声明一个静态方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> C(object):<br>    <span class="hljs-variable">@staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">arg1, arg2, ...</span>):<br>        ...<br></code></pre></td></tr></table></figure><p>以上实例声明了静态方法 <strong>f</strong>，从而可以实现实例化使用<strong>C().f()</strong>，当然也可以不实例化调用该方法<strong>C.f()</strong>。</p><h2 id="函数语法-1">函数语法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">staticmethod</span><span class="hljs-params">(function)</span></span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>无</li></ul><h2 id="实例-2">实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python # -*- coding: UTF-8 -*-  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">object</span>):    <br><span class="hljs-meta">    @staticmethod    </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>);  <br>        <br>C.f();          <span class="hljs-comment"># 静态方法无需实例化 </span><br>cobj = C() <br>cobj.f()        <span class="hljs-comment"># 也可以实例化后调用</span><br></code></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">runoob</span><br><span class="hljs-attribute">runoob</span><br></code></pre></td></tr></table></figure><hr /><h1 id="python-all函数">python all函数</h1><h2 id="描述-1">描述</h2><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为TRUE，<u>如果是返回 True，否则返回 False。</u></p><p>元素除了是 0、空、None、False 外都算 True。</p><p>函数等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">iterable</span>):<br>  <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> iterable:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> element:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>Python 2.5 以上版本可用。</p><h3 id="语法-1">语法</h3><p>以下是 all() 方法的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">all</span><span class="hljs-params">(iterable)</span></span><br></code></pre></td></tr></table></figure><h3 id="参数-1">参数</h3><ul><li>iterable -- 元组或列表。</li></ul><h3 id="返回值-1">返回值</h3><p>如果iterable的所有元素不为0、''、False或者iterable为空，all(iterable)返回True，否则返回False；</p><p><strong>注意：</strong>空元组、空列表返回值为True，这里要特别注意。</p><hr /><h2 id="实例-3">实例</h2><p>以下展示了使用 all() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]) <span class="hljs-comment"># 列表list，元素都不为空或0</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>])  <span class="hljs-comment"># 列表list，存在一个为空的元素</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>，<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])      <span class="hljs-comment"># 列表list，存在一个为0的元素</span><br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>)) <span class="hljs-comment"># 元组tuple，元素都不为空或0</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>))  <span class="hljs-comment"># 元组tuple，存在一个为空的元素</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))      <span class="hljs-comment"># 元组tuple，存在一个为0的元素</span><br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>([])       <span class="hljs-comment"># 空列表</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>(())       <span class="hljs-comment"># 空元组</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><hr /><h1 id="python-enumerate函数">python enumerate()函数</h1><h2 id="描述-2">描述</h2><p>enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for 循环当中。</p><p>Python 2.3. 以上版本可用，2.6 添加 start 参数。</p><h3 id="语法-2">语法</h3><p>以下是 enumerate() 方法的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">enumerate</span><span class="hljs-params">(sequence, [start=<span class="hljs-number">0</span>])</span></span><br></code></pre></td></tr></table></figure><h3 id="参数-2">参数</h3><ul><li>sequence -- 一个序列、迭代器或其他支持迭代对象。</li><li>start -- 下标起始位置的值。</li></ul><h3 id="返回值-2">返回值</h3><p>返回 enumerate(枚举) 对象。</p><hr /><h2 id="实例-4">实例</h2><p>以下展示了使用 enumerate() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>seasons = [<span class="hljs-string">&#x27;Spring&#x27;</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">enumerate</span>(seasons))<br>[(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Spring&#x27;</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">enumerate</span>(seasons, start=<span class="hljs-number">1</span>))    <span class="hljs-comment"># 下标从 1 开始</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Spring&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>)]<br></code></pre></td></tr></table></figure><h3 id="普通的-for-循环">普通的 for 循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>i = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>seq = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> seq:<br><span class="hljs-meta">... </span>  <span class="hljs-built_in">print</span> i, seq[i]<br><span class="hljs-meta">... </span>  i += <span class="hljs-number">1</span><br>...<br><span class="hljs-number">0</span> one<br><span class="hljs-number">1</span> two<br><span class="hljs-number">2</span> three<br></code></pre></td></tr></table></figure><h3 id="for-循环使用-enumerate">for 循环使用 enumerate</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>seq = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i, element <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(seq):<br><span class="hljs-meta">... </span>  <span class="hljs-built_in">print</span> i, element<br>...<br><span class="hljs-number">0</span> one<br><span class="hljs-number">1</span> two<br><span class="hljs-number">2</span> three<br></code></pre></td></tr></table></figure><hr /><h1 id="python-ord-函数">Python ord() 函数</h1><hr /><h2 id="描述-3">描述</h2><p>ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr()函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python定义范围，则会引发一个 TypeError 的异常。</p><h3 id="语法-3">语法</h3><p>以下是 ord() 方法的语法:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-variable">c</span>)</span><br></code></pre></td></tr></table></figure><h3 id="参数-3">参数</h3><ul><li>c -- 字符。</li></ul><h3 id="返回值-3">返回值</h3><p>返回值是对应的十进制整数。</p><hr /><h2 id="实例-5">实例</h2><p>以下展示了使用 ord() 方法的实例：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt;<span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;a&#x27;</span>) </span><br><span class="hljs-function"><span class="hljs-number">97</span> </span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;b&#x27;</span>)</span><br><span class="hljs-number">98</span> <br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;c&#x27;</span>) </span><br><span class="hljs-function"><span class="hljs-number">99</span></span><br></code></pre></td></tr></table></figure><hr /><h1 id="python-any-函数">Python any() 函数</h1><hr /><h2 id="描述-4">描述</h2><p>any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回False，<u>如果有一个为 True，则返回 True</u>。</p><p>元素除了是 0、空、FALSE 外都算 TRUE。</p><p>函数等价于：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> <span class="hljs-keyword">any</span>(iterable):<br>    <span class="hljs-keyword">for</span> element in iterable:<br>        <span class="hljs-keyword">if</span> element:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span><br></code></pre></td></tr></table></figure><p>Python 2.5 以上版本可用。</p><h3 id="语法-4">语法</h3><p>以下是 any() 方法的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">any</span><span class="hljs-params">(iterable)</span></span><br></code></pre></td></tr></table></figure><h3 id="参数-4">参数</h3><ul><li>iterable -- 元组或列表。</li></ul><h3 id="返回值-4">返回值</h3><p>如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。</p><hr /><h2 id="实例-6">实例</h2><p>以下展示了使用 any() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-built_in">any</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>])  <span class="hljs-comment"># 列表list，元素都不为空或0 </span><br><span class="hljs-literal">True</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>])   <span class="hljs-comment"># 列表list，存在一个为空的元素 </span><br><span class="hljs-literal">True</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>([<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-literal">False</span>])        <span class="hljs-comment"># 列表list,元素全为0,&#x27;&#x27;,false </span><br><span class="hljs-literal">False</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>))  <span class="hljs-comment"># 元组tuple，元素都不为空或0 </span><br><span class="hljs-literal">True</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>))   <span class="hljs-comment"># 元组tuple，存在一个为空的元素 </span><br><span class="hljs-literal">True</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>((<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-literal">False</span>))        <span class="hljs-comment"># 元组tuple，元素全为0,&#x27;&#x27;,false </span><br><span class="hljs-literal">False</span>   <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>([]) <span class="hljs-comment"># 空列表 </span><br><span class="hljs-literal">False</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>(()) <span class="hljs-comment"># 空元组 </span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>学习</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理-学习笔记-图像压缩</title>
    <link href="/2024/04/12/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/"/>
    <url>/2024/04/12/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h1id="数字图像处理-学习笔记-图像压缩">数字图像处理-学习笔记-图像压缩</h1><span id="more"></span><h1 id="图像压缩">6.11 图像压缩</h1><h2 id="图像压缩基础知识">图像压缩基础知识</h2><p><strong>首先</strong></p><p>数据 <span class="math inline">\(\neq\)</span> 信息</p><p>数据是信息的载体。</p><blockquote><p>当我们打电话时，电话对面的人和你交流，我们通过电话传输的是电波，是数据，而对面听到的是你说的话，属于信息。</p></blockquote><p>图像压缩就是对数据进行压缩。</p><p>图像压缩很有必要</p><h3 id="可行性">可行性</h3><p>改变图像的描述方式可以变更存储空间。</p><blockquote><p>比如我们可以对原来8个红色的像素表示成<code>8 * R</code>，也就是说，原来我们要用八个格子装红色像素的数据，现在只要两个格子。</p></blockquote><p>上面的例子也就是我们所说的：</p><p><em>图像像素存在着大量冗余</em>。</p><p>当然图像视觉感知也存在冗余——也就是我们人眼对于微小的颜色变化是没有感知的，可以把他们用刚刚的方法缩小存储空间。</p><blockquote><p>人眼会忽略微小差距</p></blockquote><h1 id="冗余分析">6.12 冗余分析</h1><h2 id="冗余分类">冗余分类</h2><ul><li>空间冗余</li><li>时间冗余</li><li>统计冗余</li><li>视觉心理冗余</li></ul><h3 id="对于空间冗余">对于空间冗余</h3><ul><li><p>相邻像素之间存在相关性</p></li><li><p>相应帧之间相关性也很大</p><ul><li>去除冗余的方法：预测、变换</li></ul></li></ul><h3 id="对于统计冗余">对于统计冗余</h3><ul><li>信息熵</li><li>信息量</li><li>熵是平均信息量</li><li>信息量公式：<spanclass="math inline">\(I(x_n)=-log_i(P_n)\)</span></li><li>如果以2为底，单位是：比特</li><li>如果以<span class="math inline">\(e\)</span>为底，单位是：奈特</li><li>如果以<span class="math inline">\(10\)</span>为底，单位是哈特</li><li>信息量怎么解释：<ul><li>你出现的概率越小，你越不寻常，信息量也就更大；</li><li>你出现的概率越大，你越平凡寻常，信息量也就越小。</li></ul></li><li>等概率的熵最大<ul><li>但是我们图片的信息熵不是等概率分布的</li><li>所以可以采用一些方法来减少视觉系统的冗余<ul><li>量化（IGS）</li></ul></li></ul></li></ul><ol type="1"><li>编码方式</li></ol><p>原始图像-&gt;去相关–&gt;量化–&gt;熵编码</p><p>解码–&gt;&gt;熵解码–&gt;&gt;解相关</p><ol start="2" type="1"><li>去相关技术</li></ol><ul><li>基于预测</li><li>基于矢量量化</li><li>基于变换</li><li>基于子带变换</li></ul><ol start="3" type="1"><li>信息熵编码/统计编码：</li></ol><p>利用图像灰度分布统计特性</p><p>均匀的特点，采用不等字长进行编码。</p><h3 id="图像压缩的分类">图像压缩的分类</h3><ul><li>无损压缩-可逆</li><li>有损压缩-不可逆</li></ul><blockquote><p>常见的图片格式：</p><ul><li>\1. JPEG (或JPG)：广泛用于照片和网页图像，支持<strong>有损压缩</strong>，可以减小文件大小。</li><li>\2.PNG：支持透明背景，<strong>无损压缩</strong>，常用于网页设计和图标。</li><li>\3. GIF：支持动画和透明背景，但颜色限制较多（最多256色），常用于简单动画和图标。</li><li>\4.BMP：位图格式，<strong>通常不进行压缩</strong>，因此文件较大，常用于Windows操作系统。</li><li>\5.TIFF：主要用于专业图像存储，支持<strong>无损压缩</strong>和多种颜色深度，常用于印刷行业。</li><li>\6.RAW：相机原始数据格式，未经处理的图像文件，保留了拍摄时的全部信息，适合后期编辑。</li><li>\7. SVG ：矢量图像格式，适合图形设计，可以无限放大而不失真。</li><li>\8.WebP：由Google开发，旨在提供比JPEG更好的压缩，支持<strong>有损和无损压缩</strong>，以及动画和透明度。</li></ul></blockquote><h1 id="实验">实验</h1><p>用python进行实验</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 读取图像</span><br>image = cv2.imread(<span class="hljs-string">&#x27;1.1.jpg&#x27;</span>)<br>scale_factor = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 缩小比例，根据需要调整</span><br>image = cv2.resize(image, <span class="hljs-literal">None</span>, fx=scale_factor, fy=scale_factor)<br><br><span class="hljs-comment"># 保存图片为test1.jpg有损压缩</span><br>cv2.imwrite(<span class="hljs-string">&#x27;test1.jpg&#x27;</span>,image)<br><br><span class="hljs-comment"># 读取test1.jpg文件</span><br>image1 = cv2.imread(<span class="hljs-string">&#x27;test1.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 想减查看原图和读取的图片的差别</span><br>sub = image1-image<br><br><span class="hljs-comment"># 输出图片效果</span><br>cv2.imshow(<span class="hljs-string">&quot;resized_image&quot;</span>, image)<br>cv2.imshow(<span class="hljs-string">&quot;image1&quot;</span>, image1)<br>cv2.imshow(<span class="hljs-string">&quot;sub&quot;</span>, sub)<br><br>cv2.waitKey()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h2 id="实验效果图"><strong>实验效果图</strong></h2><h3 id="原图">原图</h3><figure><img src="https://img2.imgtp.com/2024/04/10/3aCYgxgt.jpg"alt="1.1.jpg" /><figcaption aria-hidden="true">1.1.jpg</figcaption></figure><h3 id="保存后的的jpg格式图片">保存后的的jpg格式图片</h3><figure><img src="https://pic.imgdb.cn/item/6618c64368eb93571317d9bb.jpg"alt="test1.jpg" /><figcaption aria-hidden="true">test1.jpg</figcaption></figure><h3 id="和原图相减后">和原图相减后</h3><figure><img src="https://s21.ax1x.com/2024/04/11/pFXWdhj.jpg" alt="sub.jpg" /><figcaption aria-hidden="true">sub.jpg</figcaption></figure><h2 id="效果分析">效果分析</h2><ul><li><p>可以看出，保存后的结果和原图的差别不大。</p></li><li><p>当我们进行想减，在显示原图后的结果，可以明显看出差别。</p></li><li><p>图像信息丰富的地方失去了一些细节，但是我们的视觉感知不大；</p></li><li><p>而图像复杂度低的地方损失的像素不是很多。</p></li></ul><h1 id="总结">总结</h1><p>本次实验总结了图像压缩的方法、分类，还提出了一些图片保存的格式，以及通过实验来验证了会有损压缩图片的像素，对未来图片的加密、图片处理来说，可能会造成复原噪点、图像损失。</p><p>但是图像压缩对于网站来说是很有必要的，可以加快网站对图片的加载速度。</p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
      <tag>数字图像处理</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我为什么一定要写博客</title>
    <link href="/2024/04/11/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/04/11/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本文解释了我为什么们一定要搞一个博客，为什么要写作。</p><p><span id="more"></span></p><h1 id="为什么要搞博客">为什么要搞博客</h1><p>我要搞博客？其实在很久之前，我就已经在心里有过构想：为什么不自己搞一个博客？</p><p>起因是自己对于每天的学习笔记，每天的学习到的知识，想做一个梳理的时候，发现自己没有输出，没有反馈，自己做的事不知道是不是正确的。</p><p>所以我的第一篇博客，就将自己曾经翻译的一篇论文（还有自己的思考）发布到了csdn里。</p><p>刚开始也没什么，但是看到博客阅读量不断上来后，自己的自豪和骄傲就也跟着上来了，但是当时的自己没有付诸行动，只是想着：要不？自己搞一个博客？</p><p>后面行动的契机是参加简历比赛。</p><p>当老师说，如果别人要看你的博客，要输入一大段的网址，那估计很大概率不会去看，因为呈现在纸面上的东西，如果很长，很麻烦，那么就会很少有人关注。</p><p>我说，那我做一个博客吧。</p><h1 id="写博客不是真的一时兴起">写博客不是真的一时兴起</h1><p>我读过一本书，《认知觉醒》，是一本讲诉你是为什么会被手机偷走时间、为什么每天嘴上懊悔着今天一事无成，但依旧刷着手机，书里给了我很多答案。</p><p>书里作者也曾每天浑浑噩噩，耍耍手机，每天到家也是无心做其他事，只有刷手机。</p><p>早上立的宏图大志，晚上回家到头就刷手机。</p><p>我当时也这样，浑浑噩噩，耍耍手机，后面真的觉得，自己是不是应该改变一下自己。</p><p>书里给个神奇的方法：早、写、读、跑、冥想。</p><hr /><p>早：早起。我翻看优秀的人的公众号，比如：Tsinghuajoking——卓晴卓大的公众号。</p><p>我时常佩服他每天更新的频率，365天不曾间断过。我这个大学生，精力应该比他充沛，也时常会觉得今天怎么更新法、经常会到大晚上才更新。</p><p>我一看他的发表时间，哦！原来如此！</p><p>他每天估计6点起床，闲暇之时才抽空写的文章，八点左右一定发布！</p><p>早上的时间多美好啊，走在路上，听着鸟语、踩着落叶🍂，看学校的环卫打扫卫生，也算惬意。</p><p>当然，我做不到6点起来，只能做到8点左右起来，水篇博客。</p><hr /><p>写：写作。对自己知识的梳理。其实写作更多的是记录自己的反思，自己的思考和自己的感悟。</p><p>我的行文脉络、语言措辞还有待提升，写作逼着我去抠每个词，每句话之间的联系，帮助我有更好的语言逻辑结构、提升我的行文能力。</p><p>除此以外，我们说，学习是吸收知识的过程，但是我们要巩固知识，还需要输出知识，得到反馈，修改反馈才能更好的巩固知识。</p><p>写博客就是一个输出的过程，我开通评论功能，也希望大家能对我的文章提出指导意见，本人才疏学浅，自己的浅薄知识，难免有点错误，望大家不吝指正。</p><hr /><p>读：读书。读书对知识获取最快的途径，一个人的知识、思想、经验就浓缩在一本书里，但也并不是什么都值得读，有些人有些书你就是读不下去，我们要学会筛选，取其精华，去其糟粕，那我们想要的，而不是一本书里，什么都想要。不太现实，也不合理。但多读书总是好的，和别人的思想进行碰撞，不管对方是哪里的人、什么职业的人，与他们交流可以让我学习到不同的知识、见识到不同的东西、了解不同的见地。</p><p>交流让我的见识变广，交流让我对世界的认识变充实。</p><p>我对我初中学生讲：能读就读吧，读书的高低，决定了你未来玩的上限。</p><hr /><p>跑：跑步。其实跑步不是很全面，其实可以说是锻炼。锻炼可以提高我们的多巴胺分泌，锻炼的好处除了提高我们身体外，还有脑子。锻炼可以促进血液流动的同时，会帮助我们大脑清理留在里面的垃圾。</p><p>我的一个同学，当时谈恋爱初期，心情不好的时候跟我聊天。我说，心情不好，就会去跑步吧。他跑完后我问他：“怎么样？”，“轻松多了”，他说。如果说德智体美劳全面发展，那肯定是少不了运动。</p><p>当我早上不够清醒，也会跳起来动一动。其实，在我们想不出东西的时候，适当的动一动是有必要的，适当的划水，除了更好的发散思维，还有让自己的大脑休息一下，以便更好地学习。</p><hr /><p>冥想。冥想很少有人提及，它的好处我讲的可能不是很全面（虽然前面的也不是很全面）。</p><p>但我还是想推荐大家试试，如果你感到心情烦躁或者注意力无法集中，可以来试试它，一两天以后，一定会有感觉的。</p><p>—</p><h1 id="感谢万能的开源">感谢万能的开源</h1><p>其实写博客是为了帮助我能和别人交流，不单单是在现实生活中。</p><p>在网上，我能和各种各样的人交流，可以进一步拓宽我的知识面，和别人的交流能更进一步帮助我改进我自己。</p><p>当然，写博客不是什么很难的事，打字就行了。</p><p>搭建博客的方法，网上教程很多，我很感谢它们的无私奉献，感谢开源的那一群人。</p>]]></content>
    
    
    <categories>
      
      <category>小记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人</tag>
      
      <tag>小记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像加密-DNA运算的图像加密学习</title>
    <link href="/2024/04/10/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86-DNA%E8%BF%90%E7%AE%97%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/10/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86-DNA%E8%BF%90%E7%AE%97%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="图像加密-dna加密-学习笔记">图像加密-DNA加密-学习笔记</h1><p>本文探究如何对图像二进制编码进行图像DNA加密。</p><p><span id="more"></span></p><blockquote><p>密码学是用于保护数据安全的工具，从古老的凯撒密码到现代密码学，已经两千多年了。脱氧核糖核酸（DNA）是生物遗传物质，携带生命的遗传信息，自从Watson和Crick在1953年发现DNA之后，人们发现和发展了许多操作DNA的方法，同时也发现了DNA计算具有某些电子计算机无可比拟和替代的优越性。密码学和遗传学原本是毫不相关的两个学科。然而，随着现代科技的发展，近年来密码学和DNA开始走到了一起，并且关系越来越密切。</p><p>1994年美国南加州大学的Adleman成功地完成了用DNA计算来解决一个NP完全问题的实验，从而开创了DNA计算研究的新纪元。自此以后，越来越多的目光集中到对这门新兴学科的研究上来，其中包括了不少计算机专家和密码学界的知名人士，他们开始关注DNA计算对密码学及信息安全的影响，开始思考能否在DNA的领域里开辟密码的新天地。</p></blockquote><h2 id="dna加密">DNA加密</h2><p>目前常用的DNA加密，有多种方法，比如：先将图像转化成二进制码，在将他与另一图像，进行二进制<u>相加、相减、同或、异或</u>；</p><blockquote><p><strong>异或（xor）</strong>，是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。</p><ul><li><p>如果a、b两个值不相同，则异或结果为1。</p></li><li><p>如果a、b两个值相同，异或结果为0。</p></li></ul><p><strong>同或（XNOR）</strong>，电路表示则为同或门，双输入若相同则输出为1，不同则输出为0。</p></blockquote><p><strong>举例子：</strong></p><p>对于图像像素来说，每张图片有三种颜色，<strong>RGB</strong>三色(python的opencv在处理图像时，默认处理的顺序是<strong>BGR</strong>，要注意！！)，0~255代表它的亮度。</p><p>每个颜色不同、亮度不同，颜色就不同；</p><p>我们使用八位二进制码，也就是00000000来表示亮度为0，11111111表示亮度为255——也就是最亮，0是最暗也就是全黑。</p><h3 id="预处理">预处理</h3><p>两图像相加，我们要先能保证，他们两张图片宽高长得一样，不然会没得减、或者没能全部覆盖我们要加密的图像。</p><p><strong>预处理代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 读取彩色图像</span><br>image = cv2.imread(<span class="hljs-string">&#x27;1.1.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 获取图像尺寸</span><br>height, width, _ = image.shape<br>M = height<br>N = width<br><br><span class="hljs-comment"># 将图像拆分为三个通道</span><br>I1 = image[:, :, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 蓝色通道</span><br>I2 = image[:, :, <span class="hljs-number">1</span>]  <span class="hljs-comment"># 绿色通道</span><br>I3 = image[:, :, <span class="hljs-number">2</span>]  <span class="hljs-comment"># 红色通道</span><br><br><span class="hljs-comment"># 找到最大的长宽</span><br><span class="hljs-comment"># 调整图像大小为16的倍数</span><br>max_dim = <span class="hljs-built_in">max</span>(height, width)<br>max_dim = (max_dim + <span class="hljs-number">15</span>) // <span class="hljs-number">16</span> * <span class="hljs-number">16</span>  <span class="hljs-comment"># 向上取整到最近的16的倍数</span><br><br><span class="hljs-comment"># 创建一个新的空白图像</span><br>padded_I1 = np.zeros((max_dim, max_dim), dtype=np.uint8)<br>padded_I2 = np.zeros((max_dim, max_dim), dtype=np.uint8)<br>padded_I3 = np.zeros((max_dim, max_dim), dtype=np.uint8)<br><br><span class="hljs-comment"># 将原始图像放入新的空白图像中</span><br>padded_I1[:M, :N] = I1<br>padded_I2[:M, :N] = I2<br>padded_I3[:M, :N] = I3<br><br>scale_factor = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 缩小比例，根据需要调整</span><br>padded_I1 = cv2.resize(padded_I1, <span class="hljs-literal">None</span>, fx=scale_factor, fy=scale_factor)<br>padded_I2 = cv2.resize(padded_I2, <span class="hljs-literal">None</span>, fx=scale_factor, fy=scale_factor)<br>padded_I3 = cv2.resize(padded_I3, <span class="hljs-literal">None</span>, fx=scale_factor, fy=scale_factor)<br><br><span class="hljs-comment"># # 分别展示三张通道图片</span><br>cv2.imshow(<span class="hljs-string">&#x27;Bed Channel&#x27;</span>, padded_I1)<br>cv2.imshow(<span class="hljs-string">&#x27;Green Channel&#x27;</span>, padded_I2)<br>cv2.imshow(<span class="hljs-string">&#x27;Rlue Channel&#x27;</span>, padded_I3)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br><br><span class="hljs-comment"># 输出高、宽、补零后的宽</span><br><span class="hljs-built_in">print</span>(height,width,max_dim)<br><span class="hljs-comment"># 保存不同通道的图片(选)</span><br><span class="hljs-comment"># cv2.imwrite(&#x27;lena_blue_channel.bmp&#x27;, padded_I1)</span><br><span class="hljs-comment"># cv2.imwrite(&#x27;lena_green_channel.bmp&#x27;, padded_I2)</span><br><span class="hljs-comment"># cv2.imwrite(&#x27;lena_red_channel.bmp&#x27;, padded_I3)</span><br></code></pre></td></tr></table></figure><figure><img src="https://img2.imgtp.com/2024/04/10/3aCYgxgt.jpg" alt="1.1" /><figcaption aria-hidden="true">1.1</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/o9Zzz4Ec.bmp"alt="l_red_channel" /><figcaption aria-hidden="true">l_red_channel</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="l_blue_channel" /><figcaption aria-hidden="true">l_blue_channel</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/bwHm8CQA.bmp"alt="l_green_channel" /><figcaption aria-hidden="true">l_green_channel</figcaption></figure><h3 id="相加">相加</h3><p>当两张图像，各自对应的像素相加，就有可能超过八位，所以在python中，我们使用</p><p><code>result = result &amp; 0xFF  # 只保留低8位，相当于取模256</code>或者使用numpy库中的<code>clip</code>方法：</p><p><code>result = np.clip(image1 - image2, 0, 255)</code>来对图像进行处理，防止溢出，说人话，担心出现255+1=256，超出我们定义的范围了，所以我们取模，让他重新回到我们定义的范围里。即：<spanclass="math inline">\((255+1)//256 = 0\)</span>，其中，<spanclass="math inline">\(//\)</span>是取模。</p><h4 id="取模256">取模256</h4><p><strong>代码演示如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入numpy库，重命名为np</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义变量</span><br>result1 = <span class="hljs-number">231</span><br>result2 = <span class="hljs-number">25</span><br><br><span class="hljs-comment"># 转化二进制</span><br>binary_num1 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>(result1), <span class="hljs-number">2</span>)<br>binary_num2 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>(result2), <span class="hljs-number">2</span>) <br><br><span class="hljs-comment"># 相加</span><br>result3 = binary_num1 + binary_num2 <br><br><span class="hljs-comment"># 处理溢出</span><br>result3 = result3 &amp; <span class="hljs-number">0xFF</span>  <span class="hljs-comment"># 只保留低8位，相当于取模256</span><br><br><span class="hljs-comment"># 输出二进制表示的结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(result1),<span class="hljs-built_in">bin</span>(result2),<span class="hljs-built_in">bin</span>(result3),result3)  <br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">0b11100111</span> <span class="hljs-number">0b11001</span> <span class="hljs-number">0b0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="使用clip方法">使用clip方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入numpy库，重命名为np</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 假设有两个数组表示图像像素值</span><br>image1 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">50</span>, <span class="hljs-number">220</span>, <span class="hljs-number">180</span>],[<span class="hljs-number">50</span>, <span class="hljs-number">220</span>, <span class="hljs-number">180</span>]], dtype=np.uint8)<br>image2 = np.array([[<span class="hljs-number">80</span>, <span class="hljs-number">180</span>, <span class="hljs-number">255</span>], [<span class="hljs-number">120</span>, <span class="hljs-number">190</span>, <span class="hljs-number">230</span>],[<span class="hljs-number">50</span>, <span class="hljs-number">220</span>, <span class="hljs-number">180</span>]], dtype=np.uint8)<br><br><span class="hljs-comment"># 图像加法，使用饱和运算</span><br>result = np.clip(image1 + image2, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<br><br><span class="hljs-comment"># 打印处理后的结果</span><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[180 124   0]</span><br><span class="hljs-string"> [170 154 154]</span><br><span class="hljs-string"> [100 184 104]]</span><br></code></pre></td></tr></table></figure><p>实验效果显示，两种方法都可以实现0~255的映射。</p><p>当我们把它用在图像上：</p><p><strong>原图1：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="l_blue_channel" /><figcaption aria-hidden="true">l_blue_channel</figcaption></figure><p><strong>原图2：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/7BUsYmhM.bmp"alt="2_Henon_R" /><figcaption aria-hidden="true">2_Henon_R</figcaption></figure><p><strong>得到：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/APe5HAiP.bmp"alt="Result (Addition)" /><figcaption aria-hidden="true">Result (Addition)</figcaption></figure><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_addition</span>(<span class="hljs-params">img1, img2</span>):<br>    <span class="hljs-comment"># 进行二进制相加</span><br>    result = np.clip(img1 + img2, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_subtraction</span>(<span class="hljs-params">img1, img2</span>):<br><br>    <span class="hljs-comment"># 进行二进制相减</span><br>    <span class="hljs-comment"># 由于可能存在负数，需要确保结果在 [0, 255] 范围内</span><br>    binary_result = np.clip(img1 - img2, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">return</span> binary_result<br><br><span class="hljs-comment"># 读取两个灰度图像</span><br>img1 = cv2.imread(<span class="hljs-string">&#x27;l_blue_channel.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br>img2 = cv2.imread(<span class="hljs-string">&#x27;2_Henon_R.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br><br><span class="hljs-comment"># 进行二进制相加和相减</span><br><span class="hljs-comment"># 原图1和原图2进行相加</span><br>result_add = binary_addition(img1, img2)<br><span class="hljs-comment"># 结果图-原图2=原图1</span><br>result_sub = binary_subtraction(result_add, img2)<br><br><span class="hljs-comment"># 显示结果图像</span><br>cv2.imshow(<span class="hljs-string">&#x27;Original Image 1&#x27;</span>, img1)<br>cv2.imshow(<span class="hljs-string">&#x27;Original Image 2&#x27;</span>, img2)<br>cv2.imshow(<span class="hljs-string">&#x27;Result (Addition)&#x27;</span>, result_add)<br>cv2.imshow(<span class="hljs-string">&#x27;Result (Subtraction)&#x27;</span>, result_sub)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h3 id="同或异或">同或、异或</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cv2.bitwise_xor(block1, block2)<br>cv2.bitwise_not(cv2.bitwise_xor(block1, block2))  <span class="hljs-comment"># 同或运算</span><br></code></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs smali">import cv2<br><span class="hljs-comment"># 同或、异或</span><br>image1 = cv2.imread(&#x27;l_blue_channel.bmp&#x27;, cv2.IMREAD_GRAYSCALE)<br>image2 = cv2.imread(&#x27;2_Henon_R.bmp&#x27;, cv2.IMREAD_GRAYSCALE)<br><br>tonghuo = cv2.bitwise_xor(image1, image2)<br>yihuo = cv2.bitwise_not(cv2.bitwise_xor(tonghuo, image2))  <span class="hljs-comment"># 同或运算</span><br>cv2.imshow(<span class="hljs-string">&quot;1&quot;</span>,tonghuo)<br>cv2.imshow(<span class="hljs-string">&quot;2&quot;</span>,yihuo)<br>cv2.waitKey(0)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>然后有意思的是出现了：</p><p><strong>原图：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="l_blue_channel" /><figcaption aria-hidden="true">l_blue_channel</figcaption></figure><p><strong>但是我异或、同或后的结果：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/v9CvtMds.bmp" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><p>很诡异，但是其实可以看出来，得到的图像，和原图像的差别，只是黑白值互换了。</p><p>检查代码，<del>发现确实是因为自己同或的顺序放反了。</del>再次试验后发现，同或再同或，才能得到原图像，自己是对他进行异或了，所以得不到原图像。</p><p>但是其实通过异或实验，我们也能得到大致的图像信息，说明同或、异或本身之间相关性很高。</p><p>更改代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-comment"># 同或、异或</span><br>image1 = cv2.imread(<span class="hljs-string">&#x27;l_blue_channel.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br>image2 = cv2.imread(<span class="hljs-string">&#x27;2_Henon_R.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br><br>tonghuo = cv2.bitwise_xor(image1, image2)<br>tonghuo1 = cv2.bitwise_xor(tonghuo, image2) <br>cv2.imshow(<span class="hljs-string">&quot;1&quot;</span>,tonghuo)<br>cv2.imshow(<span class="hljs-string">&quot;2&quot;</span>,tonghuo1)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>实验成功：</p><figure><img src="https://img2.imgtp.com/2024/04/10/APe5HAiP.bmp"alt="tonghuo" /><figcaption aria-hidden="true">tonghuo</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="tonghuo1" /><figcaption aria-hidden="true">tonghuo1</figcaption></figure><h3 id="互换">0-1互换</h3><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 读取灰度图像</span><br>image_gray = cv2.imread(<span class="hljs-string">&#x27;l_blue_channel.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br><br><br><span class="hljs-comment"># 获取图像尺寸</span><br>height, width = image_gray.shape<br><br><span class="hljs-comment"># 将像素转换为二进制序列并进行反转</span><br>binary_image = np.zeros_like(image_gray)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(height):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(width):<br>        pixel_binary = <span class="hljs-built_in">bin</span>(image_gray[i, j])[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)  <span class="hljs-comment"># 转换为8位二进制序列</span><br>        inverted_binary = <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">if</span> bit == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">for</span> bit <span class="hljs-keyword">in</span> pixel_binary])  <span class="hljs-comment"># 反转序列</span><br>        binary_image[i, j] = <span class="hljs-built_in">int</span>(inverted_binary, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 转换为十进制并赋值给新图像</span><br><br><span class="hljs-comment"># 显示图像</span><br>cv2.imshow(<span class="hljs-string">&#x27;Inverted Binary Image&#x27;</span>, binary_image)<br>cv2.imshow(<span class="hljs-string">&#x27;image_gray Image&#x27;</span>, image_gray)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p><strong>原图：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="image_gray" /><figcaption aria-hidden="true">image_gray</figcaption></figure><p><strong>结果图：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/v9CvtMds.bmp"alt="binary_image" /><figcaption aria-hidden="true">binary_image</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>图像加密</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>笔记</tag>
      
      <tag>图像</tag>
      
      <tag>加密</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机视觉-图像视觉作业-作业5</title>
    <link href="/2024/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89%E4%BD%9C%E4%B8%9A-%E4%BD%9C%E4%B8%9A5/"/>
    <url>/2024/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89%E4%BD%9C%E4%B8%9A-%E4%BD%9C%E4%B8%9A5/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机视觉作业-作业5">计算机视觉作业-作业5</h1><p>参考教材相应章节内容，完成以下实践内容：</p><p>1、缩放操作</p><p>2、翻转操作</p><p>3、平移操作</p><p>4、旋转操作</p><p>5、倾斜操作</p><p>6、透视操作</p><p><span id="more"></span></p><hr /><ol type="1"><li>缩放操作</li></ol><p>1.1 将图像按照指定宽高进行缩放；</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>dst1 = cv2.resize(img, (<span class="hljs-number">100</span>, <span class="hljs-number">100</span>))  <span class="hljs-comment"># 按照宽100像素、高100像素的大小进行缩放</span><br>dst2 = cv2.resize(img, (<span class="hljs-number">400</span>, <span class="hljs-number">400</span>))  <span class="hljs-comment"># 按照宽400像素、高400像素的大小进行缩放</span><br>cv2.imwrite(<span class="hljs-string">&quot;1.1.1.jpg&quot;</span>,img) <span class="hljs-comment"># 保存原图图像</span><br>cv2.imwrite(<span class="hljs-string">&quot;1.1.2.jpg&quot;</span>,dst1)<br>cv2.imwrite(<span class="hljs-string">&quot;1.1.3.jpg&quot;</span>,dst2)<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOa8Jg.jpg"alt="1.1.1.jpg" /><figcaption aria-hidden="true">1.1.1.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/09/pFOaQdf.jpg"alt="1.1.2.jpg" /><figcaption aria-hidden="true">1.1.2.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/09/pFOa3FS.jpg"alt="1.1.3.jpg" /><figcaption aria-hidden="true">1.1.3.jpg</figcaption></figure><p>1.2 指定比例进行缩放;</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>dst3 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">1</span> / <span class="hljs-number">3</span>, fy=<span class="hljs-number">1</span> / <span class="hljs-number">2</span>)  <span class="hljs-comment"># 将宽缩小到原来的1/3、高缩小到原来的1/2</span><br>dst4 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">1.5</span>, fy=<span class="hljs-number">1.5</span>)  <span class="hljs-comment"># 将宽高扩大1.5倍</span><br>cv2.imwrite(<span class="hljs-string">&quot;1.2.1.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;1.2.2.jpg&quot;</span>,dst3)<br>cv2.imwrite(<span class="hljs-string">&quot;1.2.3.jpg&quot;</span>,dst4)<br><br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOaGWQ.jpg"alt="1.2.1.jpg" /><figcaption aria-hidden="true">1.2.1.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/09/pFOalo8.jpg"alt="1.2.2.jpg" /><figcaption aria-hidden="true">1.2.2.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/09/pFOaNyn.jpg"alt="1.2.3.jpg" /><figcaption aria-hidden="true">1.2.3.jpg</figcaption></figure><ol start="2" type="1"><li>翻转操作</li></ol><p>实现多种不同翻转效果；</p><p>2.1 垂直翻转</p><p>2.2 水平翻转</p><p>2.3 对角线翻转</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>dst1 = cv2.flip(img, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 沿X轴翻转</span><br>dst2 = cv2.flip(img, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 沿Y轴翻转</span><br>dst3 = cv2.flip(img, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># 同时沿X轴、Y轴翻转</span><br>cv2.imwrite(<span class="hljs-string">&quot;2.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;2.1.jpg&quot;</span>,dst1)<br>cv2.imwrite(<span class="hljs-string">&quot;2.2.jpg&quot;</span>,dst2)<br>cv2.imwrite(<span class="hljs-string">&quot;2.3.jpg&quot;</span>,dst3)<br><br></code></pre></td></tr></table></figure><p>效果图：</p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="2.0.jpg" /><figcaption aria-hidden="true">2.0.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOIqPg.jpg" alt="2.1.jpg" /><figcaption aria-hidden="true">2.1.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOIHIS.jpg" alt="2.2.jpg" /><figcaption aria-hidden="true">2.2.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOITVf.jpg" alt="2.3.jpg" /><figcaption aria-hidden="true">2.3.jpg</figcaption></figure><ol start="3" type="1"><li>平移操作</li></ol><p>实现图像向不同方向平移效果；</p><p>3.1 横坐标向右移动50像素 纵坐标向下移动100像素</p><p>3.2 横坐标不变 纵坐标向上移动50像素</p><p>3.3 横坐标向左移动200像素 纵坐标不变</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>M1 = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>],  <span class="hljs-comment"># 横坐标向右移动50像素</span><br>                [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>]])  <span class="hljs-comment"># 纵坐标向下移动100像素</span><br>M2 = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],  <span class="hljs-comment"># 横坐标不变</span><br>                [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>]])  <span class="hljs-comment"># 纵坐标向上移动50像素</span><br>M3 = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>],  <span class="hljs-comment"># 横坐标向左移动200像素</span><br>                [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>]])  <span class="hljs-comment"># 纵坐标不变</span><br>dst1 = cv2.warpAffine(img, M1, (cols, rows))<br>dst2 = cv2.warpAffine(img, M2, (cols, rows))<br>dst3 = cv2.warpAffine(img, M3, (cols, rows))<br>cv2.imwrite(<span class="hljs-string">&quot;3.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;3.1.jpg&quot;</span>,dst1)<br>cv2.imwrite(<span class="hljs-string">&quot;3.2.jpg&quot;</span>,dst2)<br>cv2.imwrite(<span class="hljs-string">&quot;3.3.jpg&quot;</span>,dst3)<br></code></pre></td></tr></table></figure><p>效果图：</p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="3.0.jpg" /><figcaption aria-hidden="true">3.0.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOIIqP.jpg" alt="3.1.jpg" /><figcaption aria-hidden="true">3.1.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOI7a8.jpg" alt="3.2.jpg" /><figcaption aria-hidden="true">3.2.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/aaTUr9yc.jpg"alt="3.3.jpg" /><figcaption aria-hidden="true">3.3.jpg</figcaption></figure><ol start="4" type="1"><li>旋转操作</li></ol><p>实现图像逆时针旋转效果；</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>center = (rows / <span class="hljs-number">2</span>, cols / <span class="hljs-number">2</span>)  <span class="hljs-comment"># 图像的中心点</span><br>M = cv2.getRotationMatrix2D(center, <span class="hljs-number">30</span>, <span class="hljs-number">0.8</span>)  <span class="hljs-comment"># 以图像为中心，逆时针旋转30度，缩放0.8倍</span><br>dst = cv2.warpAffine(img, M, (cols, rows))  <span class="hljs-comment"># 按照M进行仿射</span><br>cv2.imwrite(<span class="hljs-string">&quot;4.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;4.1.jpg&quot;</span>,dst)<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="4.0.jpg" /><figcaption aria-hidden="true">4.0.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/1LvgNtED.jpg"alt="4.1.jpg" /><figcaption aria-hidden="true">4.1.jpg</figcaption></figure><ol start="5" type="1"><li>倾斜操作</li></ol><p>实现图像分别向左和右倾斜效果；</p><p>5.1 图像右倾斜</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>p1 = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，原图三个点</span><br>p1[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标</span><br>p1[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标</span><br>p1[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标</span><br>p2 = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，倾斜图三个点</span><br>p2[<span class="hljs-number">0</span>] = [<span class="hljs-number">50</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标，向右挪50像素</span><br>p2[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标，位置不变</span><br>p2[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标，位置不变</span><br>M = cv2.getAffineTransform(p1, p2)  <span class="hljs-comment"># 根据三个点的变化轨迹计算出M矩阵</span><br>dst = cv2.warpAffine(img, M, (cols, rows))  <span class="hljs-comment"># 按照M进行仿射</span><br>cv2.imwrite(<span class="hljs-string">&quot;5.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;5.1.jpg&quot;</span>,dst)<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="5.0.jpg" /><figcaption aria-hidden="true">5.0.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/Ncury2ba.jpg"alt="5.1.jpg" /><figcaption aria-hidden="true">5.1.jpg</figcaption></figure><p>5.2 图像左倾斜</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>p1 = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，原图三个点</span><br>p1[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标</span><br>p1[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标</span><br>p1[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标</span><br>p2 = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，倾斜图三个点</span><br>p2[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标，向右挪50像素</span><br>p2[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">51</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标，位置不变</span><br>p2[<span class="hljs-number">2</span>] = [<span class="hljs-number">50</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标，位置不变</span><br>M = cv2.getAffineTransform(p1, p2)  <span class="hljs-comment"># 根据三个点的变化轨迹计算出M矩阵</span><br>dst = cv2.warpAffine(img, M, (cols, rows))  <span class="hljs-comment"># 按照M进行仿射</span><br>cv2.imwrite(<span class="hljs-string">&quot;5.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;5.2.jpg&quot;</span>,dst)<br></code></pre></td></tr></table></figure><p><strong>图像图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="5.0.jpg" /><figcaption aria-hidden="true">5.0.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/R6c02Daj.jpg"alt="5.2.jpg" /><figcaption aria-hidden="true">5.2.jpg</figcaption></figure><ol start="6" type="1"><li>透视操作</li></ol><p>模拟从底部观察图像得到的透视效果；</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>p1 = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，保存原图四个点</span><br>p1[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标</span><br>p1[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标</span><br>p1[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标</span><br>p1[<span class="hljs-number">3</span>] = [cols - <span class="hljs-number">1</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 右下角点坐标</span><br>p2 = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，保存透视图四个点</span><br>p2[<span class="hljs-number">0</span>] = [<span class="hljs-number">90</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标，向右移动90像素</span><br>p2[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">90</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标，向左移动90像素</span><br>p2[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标，位置不变</span><br>p2[<span class="hljs-number">3</span>] = [cols - <span class="hljs-number">1</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 右下角点坐标，位置不变</span><br>M = cv2.getPerspectiveTransform(p1, p2)  <span class="hljs-comment"># 根据四个点的变化轨迹计算出M矩阵</span><br>dst = cv2.warpPerspective(img, M, (cols, rows))  <span class="hljs-comment"># 按照M进行仿射</span><br>cv2.imwrite(<span class="hljs-string">&quot;6.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;6.1.jpg&quot;</span>,dst)<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="6.0.jpg" /><figcaption aria-hidden="true">6.0.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/f1yRErS0.jpg"alt="6.1.jpg" /><figcaption aria-hidden="true">6.1.jpg</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
      <tag>计算机视觉</tag>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>混沌的验证方法</title>
    <link href="/2024/04/08/%E6%B7%B7%E6%B2%8C%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/"/>
    <url>/2024/04/08/%E6%B7%B7%E6%B2%8C%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>所有混沌系统一定是非线性系统，但非线性系统不一定是混沌系统。确定一个系统是否存在混沌需要从多方面加以分析，结合定性分析系统机理和其他方法，一下简介一些常用的判别系统或时间序列是否具有混沌特性的方法。</p><p><span id="more"></span></p><ol type="1"><li><p>Poincare截面法：在相空间中选取一截面，在截面上某一对共轭变量构成的截面称为Poincare截面。当Poincare截面上是一些成片的具有分形结构的密集点时，说明系统是混沌的。</p></li><li><p>Lyapunov指数法：李雅普诺夫指数是指在相空间中相互靠近的两条轨线随着时间的推移，按指数分离或聚合的平均变化速率，正的李雅普诺夫指数意味着混沌。</p></li><li><p>时域及相轨迹的直接观察方法：在时域分析里，可通过观察各个状态变量的时域波形，发现分岔和阵发性混沌。</p></li><li><p>分维数：混沌运动具有某种潜在的秩序，并能以相对较少的自由度来描述。分维数给出了有关混沌的自由度的信息，分维数的具体形式有很多种。</p></li><li><p>Kolmogorov熵：关联维数和Kolmogorov熵的计算可以在相空间中进行，包括最小二乘法等。</p></li><li><p>（1）功率谱法。</p><p>时间序列的图像看上去不规则,但其功率谱却可能呈现出规律。若功率谱图无明显的峰值或峰值连成一片,则对应于混沌序列,系统作混沌运动若功率谱图具有单峰或几个峰,则对应于周期序列或拟周期序列,系统作周期运动。</p><p>（2）准相图法。</p><p>如果准相图是简单的闭环曲线,那么系统作周期运动如果准相图为自身相交的闭环曲线,那么系统作准周期运动如果准相图具有无限精细的分形结构,则系统作混沌运动。</p><p>（3）分频采样法。</p><p>对周期外力作用下的非线性振子,研究其倍周期分岔和混沌现象,可采用频闪采样法,是目前辨认长周期混沌带的最有效的方法。对于受迫振动,采样周期常取为外控力周期,如果采样点只是在一定区域内密集的点而且具有层次结构,则此伪随机运动便是混沌。</p></li></ol><p>ps:test，看看能不能调用评论系统了！</p>]]></content>
    
    
    <categories>
      
      <category>图像加密算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
      <tag>加密</tag>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的基础用法以及写作技巧汇总</title>
    <link href="/2024/04/07/hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/07/hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p>本文对于hexo的一些语法进行简单讲解，主要记录了hexo特定的一些写作方法以及常见的一些参数如何设置。</p><p><span id="more"></span></p><h1 id="hexo特定语法">hexo特定语法</h1><h2 id="新建博客文章">新建博客文章</h2><p>对于新搭建好的博客，你的文章该如何创建？在你的博客根目录下，打开<code>git bash here</code> ，然后输入 <code>hexo new 你的文章标题</code>就在你博客根目录下的 <code>source/_posts</code>里生成<code>你的文章标题.md</code>文件。然后你打开该文件就可以进行编辑和书写了。</p><h2 id="显示摘要">显示摘要</h2><p>所以不需要设置，只要我们在文章中插入<code>&lt;!-- more --&gt;</code>，该标签之上的是摘要，之后的内容不可见，需点击全文阅读按钮；</p><h2 id="文章内容设置">文章内容设置</h2><h3 id="显示标题图">显示标题图</h3><p>如何显示标题头图。以fluid主题为例，在你生成新的博客里，应该只有</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">title: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">title</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">date: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">date</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure><p><code>title</code> ：你的标题名字；</p><p><code>data</code> ：你的创建的时间。</p><p>添加如下代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">index_img:</span> <span class="hljs-keyword">/img/</span>banner.jpg<br><span class="hljs-symbol">banner_img:</span> <span class="hljs-keyword">/img/</span>banner.jpg<br></code></pre></td></tr></table></figure><p>其中：<code>index_img</code> 指的是你主页上看到的图片，比如</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqWzWt.png" /></p><p>这里你看到的图片，就是<code>index_img</code>定义的图片，图片可以是链接形式，也可以是存放在你的根目录下的<code>/img</code>文件夹里，必须使用相对路径，绝对路径不能部署到服务器！后面会说，相对路径也不是哪里都能放的。</p><p>打开文章后，文章里面的顶部图片由<code>banner_img</code>确定；</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqfCy8.png" /></p><p>一样的，对于图片也是可以取链接或者相对路径图片。</p><h3 id="标签和分类">标签和分类</h3><p><code>categories:</code>和<code>tags:</code>；默认不添加，要自己添加；</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span> [标签1,标签2,标签3]<br><span class="hljs-keyword">tags:</span> [tag1, tag2]注意1.属性和内容之间要有空格2.[tag1+逗号+空格+tag2]<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span><br><br>- 生活<br><br>- 年度总结<br><br>-和后面的标签之间有空格<br><br></code></pre></td></tr></table></figure><h2 id="启动公式渲染">启动公式渲染</h2><p>还是在原来的地方，输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">math</span>: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>就可以打开公式渲染；markdown公式真的很方便！真的很方便！</p><h3 id="行内公式">行内公式</h3><p>输入<code>$$</code>就可以在两个$中间填写你要的行内公式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">$x = y_</span><span class="hljs-template-variable">&#123;n+1&#125;</span><span class="language-xml"> + z^</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="language-xml">$</span><br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><span class="math inline">\(x = y_{n+1} + z^{x}\)</span></p><h3 id="块间公式">块间公式</h3><p>你可以通过<code>ctrl+shift+M</code>来获得块间公式 <spanclass="math display">\[x = y_{n+1} + z^{x}\]</span> 自动编号，自动居中，自动渲染，看着还不算难看吧~</p><h2 id="选择部署时候要上传的文件">选择部署时候要上传的文件</h2><p>我使用的是GitHub作为我的服务器部署，事先要先安装部署上传插件</p><p><strong>部署上传插件</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>当我们<code>hexo clean</code> <code>hexo g</code><code>hexo d</code>三步走后，他就可以自动给你部署到GitHub上，然后我们就可以访问到了，但是部署服务器并不是什么文件都会上传到GitHub上的，比如：</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqfpSP.png" /></p><p>这是我<code>hexo d</code>后GitHub上的文件，再看我本地端的文件</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqWxJI.png" /></p><p>你会发现，少了一些文件，多了一些文件，当我们打开<code>.gitignore</code>文件后查看</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br>_multiconfig<span class="hljs-number">.</span>yml<br></code></pre></td></tr></table></figure><p>里面出现的文件和文件夹，都没有出现在GitHub上，这就是<code>hexo</code>插件（你安装hexo后安装的插件，后续看看要不要也写一篇hexo的教程和我走过的坑），在读取这个文件后，自动忽略部署了。</p><p>当然<code>_config.yml</code>也自带了忽略编译的文件选项：</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqf9Qf.png" /></p><p><code>skip_render</code>就是你要忽略的文件，你可以自己决定要跳过哪些来减少你服务器的空间。</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ldif">跳过编译文件：<br><span class="hljs-attribute">skip_render</span>:   <span class="hljs-comment">#部署时不包含的文件</span><br><br><span class="hljs-comment">#单个文件</span><br><span class="hljs-attribute">skip_render</span>: hello.html<br><br><span class="hljs-comment">#单个文件夹下全部文件</span><br><span class="hljs-attribute">skip_render</span>: test/* <br><br><span class="hljs-comment">#单个文件夹下指定类型文件</span><br><span class="hljs-attribute">skip_render</span>: test/*.md  <br><br><span class="hljs-comment">#单个文件夹下全部文件以及子目录</span><br><span class="hljs-attribute">skip_render</span>: test/**  <br><br><span class="hljs-comment">#跳过多个目录，或者多个文件</span><br><span class="hljs-attribute">skip_render</span>: [&#x27;*.html&#x27;, demo/**, test/*]<br></code></pre></td></tr></table></figure><h1 id="typora-写作技巧及常见快捷键">typora 写作技巧及常见快捷键</h1><ul><li><p><code>ctrl+u</code>:选中的文本会出现<u>下划线</u>；</p></li><li><p><code>ctrl+b</code>:选中的文本会<strong>加粗</strong>；</p></li><li><p><code>ctrl+shift+m</code>:生成一个公式块；</p></li><li><p><code>shift+~</code>:选中的文本会<sub>变身</sub>；</p></li><li><p><code>shift+$</code>:选中的文本会变成<spanclass="math inline">\(行内公式\)</span>；</p></li><li><p><code>shift+*</code>:选中的文本会变成<em>斜体</em>；再来一次就<strong>加粗</strong>；再来一次就是<strong><em>加粗+斜体</em></strong>；</p></li><li><p><code>==</code>:高亮；但是博客好像不支持渲染，只有typora支持，可惜；</p><hr /></li><li><p><code>tab</code>:可以对列表缩进，比如</p><ul><li>这个就是被缩进了；</li><li>也可以回去<code>tab+shift</code>;</li></ul></li><li><p>就回去了。</p><hr /></li><li><p><code>---</code>:分隔符；</p></li><li><p><code>shift+方向键</code>:选中文本；</p></li></ul><h1 id="总结">总结</h1><p>对于常见的用法和比较重要的东西已经放在这里，对于未来会继续补充完善，这就是博客的魅力！！</p>]]></content>
    
    
    <categories>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的工具箱</title>
    <link href="/2024/04/07/%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    <url>/2024/04/07/%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="常使用的没用小玩样">常使用的没用小玩样</h1><h2 id="摘要">摘要</h2><p>对我常用的网站和工具进行归纳总结，方便大家的同时，让我以后也能更快速的查找相应🔗进行学习</p><p><span id="more"></span></p><h2 id="一些七七八八的工具">一些七七八八的工具</h2><ul><li>markdown编辑器：typora、我来(wolai) <ahref="(https://www.wolai.com/wolai/4N5o3xKuVqi9UrMKo1kD9k)">🔗</a>；<ul><li>typora：简洁，就像这篇博客就是用typora打的，就很适合自己安静码字，没有一丝杂念，关键是它很方便，对于一些我觉得要搞很久的比如插入链接，我们就只要复制网站，选你要插入的地方，粘贴就好了，及其舒服！！上手极快。能导出各种格式，我就喜欢在typora打公式，然后导出word，省的我word公式一个一个的画:sob:。</li><li>我来(wolai)：类notion软件，notion也是一款很出名的笔记软件，不知道有没有人用笔记软件，应该都会有听过它，他算是最出名的，但是没有官方汉化，对英文不友好的小伙伴就是拒之门外了。我来可以说是中文版的notion，高度自定义！什么叫自定义？你爱怎么做就怎么做，跟我的世界开创造一样，同理，创造模式你要创造很好看的界面，你需要学习它的使用，还是要有点时间学习他的，可能就止步于开始了。</li></ul></li><li>使用hexo搭建博客框架🔗(<ahref="https://hexo.io/zh-cn/">Hexo</a>)，使用 <ahref="https://hexo.fluid-dev.com/docs/">Fluid</a>主题；</li><li>图床工具：<a href="https://imgse.com/">路过图床</a>免费使用，不限流量，不限张数！不过不能上传黄色！赌博！违反法律法规的图片！你要想也刑。:sweat_smile:</li><li>图片压缩工具： <a href="https://tinypng.com/">Tinjimages</a>github链接<ahref="%5Bfocusbe/tinyImage:%20一款图片压缩工具%20(github.com)%5D(https://github.com/focusbe/tinyImage?tab=readme-ov-file)">🔗</a>；好用的压缩工具，在缩小图片大小的同时很大程度的保留了原来图片的细节；关键是图片小了网站加载速度也就上来了；</li><li>pdf工具大全： <ahref="https://tools.pdf24.org/zh/pdf-to-word#s=1695923633252">PDF24Tools</a>；好用，功能多，免费，几乎任何和pdf相关的问题都可以在里面找到小工具并解决。比如：</li></ul><p><img src="https://s21.ax1x.com/2024/04/07/pFqyYKH.png" /></p><ul><li><p>博客流量分析工具：<a href="https://www.51.la/">51LA</a>；个人免费，简单高效，数据可视化；包括趋势分析、访问量、在线人数、访客数、访问频次、类别占比、甚至还有地区来源；</p><p>部分截图：</p></li></ul><p><img src="https://s21.ax1x.com/2024/04/07/pFqyNqA.png" /></p><ul><li>图书看书工具：<ahref="https://zh.singlelogin.re/login.php">Z-Library项目(singlelogin.re)</a>；应该不会有人不知道免费图书白嫖网站吧~应该不会吧，那我还是写一下吧，可以搜索到几乎我大学生涯的全部教科书，当然还有期待参考书、课外书它都有，当然除极个别情况外，他还hi是没有…..那就是只能看看tb有没有卖咯；</li><li>PPT神器：<a href="https://www.mindshow.fun/#/home">MindShow</a>导入文件，生成ppt！可以导入markdown、word、xmid等文件，支持网站上编辑；免费！模板还算丰富，关键是快啊！用来应急啥的还行（小声……）</li><li>知云文献：<a href="https://www.zhiyunwenxian.cn/">知云文献</a>；划词翻译，支持各类翻译引擎：百度、谷歌、Deeply（最强机翻）等等，看文献方便，pdf编辑器该有的也都有！</li></ul><h2 id="一些奇奇怪怪的网站">一些奇奇怪怪的网站</h2><h3 id="壁纸网站">壁纸网站</h3><p><a href="https://wallhaven.cc/?utm_source=ld246.com">AwesomeWallpapers - wallhaven.cc</a></p><p><ahref="https://desk.3gbizhi.com/">电脑桌面壁纸大全-高清电脑桌面壁纸图片-超高清壁纸桌面免费下载-3g壁纸(3gbizhi.com)</a></p><h3 id="设计网站">设计网站</h3><p><ahref="https://www.zcool.com.cn/">站酷ZCOOL-设计师互动平台-打开站酷，发现更好的设计！</a></p><p><a href="https://www.ui.cn/">UICN用户体验设计平台</a></p><p><a href="https://fontawesome.com.cn/v5">图标库v5 - FontAwesome字体图标中文Icon</a></p><h3 id="python">python</h3><p><ahref="https://zhuanlan.zhihu.com/p/343256430">python简单进阶之GUI：PySimpleGUI使用教程- 知乎 (zhihu.com)</a></p><p><ahref="https://www.runoob.com/python3/python3-tutorial.html">Python3 教程| 菜鸟教程 (runoob.com)</a></p><h3 id="码字网站">码字网站</h3><p><a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法 |Markdown 官方教程</a></p><p><ahref="https://zhuanlan.zhihu.com/p/481032338">Typora(meimaid)绘制流程图- 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown教程</title>
    <link href="/2024/04/06/makedown%E6%95%99%E7%A8%8B/"/>
    <url>/2024/04/06/makedown%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="markdown基础">MarkDown基础</h1><h2 id="标题">标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 标题名字（井号的个数代表标题的级数）</span><br></code></pre></td></tr></table></figure><h1 id="一级标题使用1个">一级标题使用1个</h1><h2 id="二级标题使用2个">二级标题使用2个</h2><h3 id="三级标题使用3个">三级标题使用3个</h3><h4 id="四级标题使4用个">四级标题使4用个</h4><h5 id="五级标题使用5个">五级标题使用5个</h5><h6 id="六级标题使用6个">六级标题使用6个</h6><p class="heading" id="最多支持六级标题">最多支持六级标题</p><h2 id="文字">文字</h2><h3 id="删除线">删除线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这就是 ~~删除线~~ (使用波浪号)<br></code></pre></td></tr></table></figure><p>这就是 <del>删除线</del> (使用波浪号)</p><h3 id="斜体">斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-emphasis">*斜体*</span> 的 <span class="hljs-emphasis">_文本_</span><br></code></pre></td></tr></table></figure><p>这是用来 <em>斜体</em> 的 <em>文本</em></p><h3 id="加粗">加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**加粗**</span> 的 <span class="hljs-strong">__文本__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong>加粗</strong> 的 <strong>文本</strong></p><h3 id="斜体加粗">斜体+加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**<span class="hljs-emphasis">*斜体+加粗*</span>**</span> 的 <span class="hljs-strong">__<span class="hljs-emphasis">_文本_</span>__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong><em>斜体+加粗</em></strong> 的<strong><em>文本</em></strong></p><h3 id="下划线">下划线</h3><p>下划线是HTML语法</p><p><code>下划线</code><u>下划线(快捷键<code>command</code>+<code>u</code>，视频中所有的快捷键都是针对Mac系统，其他系统可自行查找)</u></p><h3 id="高亮需勾选扩展语法"><u>高亮</u>（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 ==斜体+加粗== 的文本<br></code></pre></td></tr></table></figure><p>这是用来 ==斜体+加粗== 的文本</p><h3 id="下标需勾选扩展语法">下标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">水 H~2~O <br>双氧水 H~2~O~2~ <br></code></pre></td></tr></table></figure><p>水 H<sub>2</sub>O</p><p>双氧水 H<sub>2</sub>O<sub>2</sub></p><h3 id="上标需勾选扩展语法">上标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">面积 m^2^ <br>体积 m^3^<br></code></pre></td></tr></table></figure><p>面积 m<sup>2</sup> 体积 m<sup>3</sup></p><h3 id="表情符号">表情符号</h3><p>Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows用户不一定支持，自己试下~）。 也可以用图片的表情，输入 <code>:</code>将会出现智能提示。</p><h4 id="一些表情例子">一些表情例子</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">:smile: :laughing: :dizzy<span class="hljs-emphasis">_face: :sob: :cold_</span>sweat: :sweat<span class="hljs-emphasis">_smile:  :cry: :triumph: :heart_</span>eyes: :relaxed: :sunglasses: :weary:<br><br>:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat<span class="hljs-emphasis">_drops: :hankey: :exclamation: :anger:</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure><p>:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile::cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1::100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone::bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><p>( Mac:<code>control</code>+<code>command</code>+<code>space</code>点选)</p><h3 id="表格">表格</h3><p>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code>来分隔表头和其他行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">name | price<br>--- | ---<br>fried chicken | 19<br>cola|5<br></code></pre></td></tr></table></figure><blockquote><p>为了使 Markdown 更清晰，<code>|</code> 和 <code>-</code>两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code>外就不需要了）。</p></blockquote><table><thead><tr class="header"><th>name</th><th>price</th></tr></thead><tbody><tr class="odd"><td>fried chicken</td><td>19</td></tr><tr class="even"><td>cola</td><td>5</td></tr></tbody></table><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用<code>|</code> 来标记单元格边界，在表头下方的分隔线标记中加入<code>:</code>，即可标记下方单元格内容的对齐方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|    name       | price |<br>| :------------ | :---: |<br>| fried chicken | 19    |<br>| cola          |  32   |<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">name</th><th style="text-align: center;">price</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">fried chicken</td><td style="text-align: center;">19</td></tr><tr class="even"><td style="text-align: left;">cola</td><td style="text-align: center;">32</td></tr></tbody></table><p>使用快捷键<code>command</code>+<code>opt</code>+<code>T</code>更方便(段落→表格→插入表格，即可查看快捷键)</p><table><thead><tr class="header"><th>name</th><th>price</th></tr></thead><tbody><tr class="odd"><td></td><td></td></tr></tbody></table><h2 id="引用">引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;“后悔创业”<br></code></pre></td></tr></table></figure><blockquote><p>“后悔创业”</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;也可以在引用中<br>&gt;&gt;使用嵌套的引用<br></code></pre></td></tr></table></figure><blockquote><p>也可以在引用中</p><blockquote><p>使用嵌套的引用</p></blockquote></blockquote><h2 id="列表">列表</h2><h3 id="无序列表--符号-空格">无序列表--符号 空格</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 可以使用 <span class="hljs-code">`*`</span> 作为标记<br><span class="hljs-bullet">+</span> 也可以使用 <span class="hljs-code">`+`</span><br><span class="hljs-bullet">-</span> 或者 <span class="hljs-code">`-`</span><br></code></pre></td></tr></table></figure><ul><li><p>可以使用 <code>*</code> 作为标记</p></li><li><p>也可以使用 <code>+</code></p></li><li><p>或者 <code>-</code></p></li></ul><h3 id="有序列表--数字-.-空格一定要空格">有序列表--数字 <code>.</code>空格（==一定要空格==）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表以数字和 <span class="hljs-code">`.`</span> 开始；<br><span class="hljs-bullet">3.</span> 数字的序列并不会影响生成的列表序列；<br><span class="hljs-bullet">4.</span> 但仍然推荐按照自然顺序（1.2.3...）编写。<br></code></pre></td></tr></table></figure><ol type="1"><li><p>有序列表以数字和 <code>.</code> 开始；</p></li><li><p>数字的序列并不会影响生成的列表序列；</p></li><li><p>但仍然推荐按照自然顺序（1.2.3...）编写。</p><p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">可以使用：数字\. 来取消显示为列表（用反斜杠进行转义）<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="合并单元格">合并单元格</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">escape</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>项目1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>项目2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>项目3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>a1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>a2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>b1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>b2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>b3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>c2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>c3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">escape</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="代码">代码</h2><h3 id="代码块">代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a)<br><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```语言名称(就会转换成对应的代码块)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="行内代码">行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">也可以通过 <span class="hljs-code">``，插入行内代码（`</span> 是 <span class="hljs-code">`Tab`</span> 键上边、数字 <span class="hljs-code">`1`</span> 键左侧的那个按键）：<br><br>例如 <span class="hljs-code">`Markdown`</span><br></code></pre></td></tr></table></figure><p><code>python</code></p><h3 id="转换规则">转换规则</h3><p>代码块中的文本（包括 Markdown 语法）都会显示为原始内容</p><h2 id="分隔线">分隔线</h2><p>可以在一行中使用三个或更多的 <code>*</code>、<code>-</code> 或<code>_</code> 来添加分隔线（``）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"><span class="hljs-strong">***</span></span><br><span class="hljs-strong"><span class="hljs-section">------</span></span><br><span class="hljs-strong"><span class="hljs-section">__<span class="hljs-emphasis">_</span></span></span><br></code></pre></td></tr></table></figure><hr /><hr /><hr /><h2 id="跳转">跳转</h2><h3 id="外部跳转--超链接">外部跳转--超链接</h3><p>格式为 <code>[提示的文字](link)</code>。(按住ctrl + 点击)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">帮助文档</span>](<span class="hljs-link">https://support.typora.io/Links/#faq</span>)<br></code></pre></td></tr></table></figure><p><a href="https://support.typora.io/Links/#faq">帮助文档</a></p><h3id="内部跳转--本文件内跳typora支持">内部跳转--本文件内跳（Typora支持）</h3><p>格式为 <code>[link text](#要去的目的地--标题）</code>。</p><p><ahref="https://www.bilibili.com/video/BV1d741147k2?spm_id_from=333.337.search-card.all.click">我想跳转</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">我想跳转</span>](<span class="hljs-link">#饼图（Pie）</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Open Links in Typora</p><p>You can use <code>command+click</code> (macOS), or<code>ctrl+click</code> (Linux/Windows) on links in Typora to jump totarget headings, or open them in Typora, or open in related apps.</p></blockquote><p><a href="#饼图（Pie）">我想跳转</a></p><h3 id="自动链接">自动链接</h3><p>使用 <code>&lt;&gt;</code> 包括的 URL或邮箱地址会被自动转换为超链接：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml">&lt;https://www.baidu.com&gt;</span><br><br>&lt;123@email.com&gt;<br></code></pre></td></tr></table></figure><p><a href="https://www.baidu.com"class="uri">https://www.baidu.com</a></p><p><a href="mailto:123@email.com">123@email.com</a></p><h2 id="图片">图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">自己起的图片名字</span>](<span class="hljs-link">图片地址或者图片本地存储的路径</span>)<br></code></pre></td></tr></table></figure><h3 id="网上的图片">网上的图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg"alt="炸鸡" /><figcaption aria-hidden="true">炸鸡</figcaption></figure><h3 id="本地图片">本地图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">friedChicken.jpg</span>)<br>在同一个文件夹里（用相对路径）<br>或者直接拷贝<br></code></pre></td></tr></table></figure><figure><img src="../../../桌面/Typora笔记/friedChicken.jpg"alt="friedChicken" /><figcaption aria-hidden="true">friedChicken</figcaption></figure><figure><img src="../../../桌面/cola.jpg" alt="cola" /><figcaption aria-hidden="true">cola</figcaption></figure><h2id="利用markdown画图需勾选扩展语法">利用Markdown画图（需勾选扩展语法）</h2><figure><img src="../../../桌面/Typora笔记/image-20200211211500416.png"alt="image-20200211211500416" /><figcaption aria-hidden="true">image-20200211211500416</figcaption></figure><p>markdown画图也是轻量级的，功能并不全。</p><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。</p><p>（不同的编辑器渲染的可能不一样）</p><h3 id="流程图graph">流程图(graph)</h3><h4 id="概述">概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph 方向描述<br><span class="hljs-code">    图表中的其他语句...</span><br></code></pre></td></tr></table></figure><p>关键字graph表示一个流程图的开始，同时需要指定该图的方向。</p><p>其中“方向描述”为：</p><table><thead><tr class="header"><th style="text-align: left;">用词</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">TB</td><td style="text-align: left;">从上到下</td></tr><tr class="even"><td style="text-align: left;">BT</td><td style="text-align: left;">从下到上</td></tr><tr class="odd"><td style="text-align: left;">RL</td><td style="text-align: left;">从右到左</td></tr><tr class="even"><td style="text-align: left;">LR</td><td style="text-align: left;">从左到右</td></tr></tbody></table><blockquote><p>T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN</p></blockquote><p>最常用的布局方向是TB、LR。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB;<br>  A--&gt;B<br>  B--&gt;C<br>  C--&gt;A<br> <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><pre><code class=" mermaid">graph LR;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><pre><code class=" mermaid">graph LR;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><h4 id="流程图常用符号及含义">流程图常用符号及含义</h4><h5 id="节点形状">节点形状</h5><table><thead><tr class="header"><th style="text-align: left;">表述</th><th style="text-align: left;">说明</th><th>含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">id<a href="#文字">文字</a></td><td style="text-align: left;">矩形节点</td><td>表示过程，也就是整个流程中的一个环节</td></tr><tr class="even"><td style="text-align: left;">id(文字)</td><td style="text-align: left;">圆角矩形节点</td><td>表示开始和结束</td></tr><tr class="odd"><td style="text-align: left;">id((文字))</td><td style="text-align: left;">圆形节点</td><td>表示连接。为避免流程过长或有交叉，可将流程切开。成对</td></tr><tr class="even"><td style="text-align: left;">id{文字}</td><td style="text-align: left;">菱形节点</td><td>表示判断、决策</td></tr><tr class="odd"><td style="text-align: left;">id&gt;文字]</td><td style="text-align: left;">右向旗帜状节点</td><td></td></tr></tbody></table><p><strong>单向箭头线段</strong>：表示流程进行方向</p><blockquote><p>id即为节点的唯一标识，A~F是当前节点名字，类似于变量名，画图时便于引用</p><p>括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A<br>  B(圆角矩形节点)<br>  C[矩形节点]<br>  D((圆形节点))<br>  E&#123;菱形节点&#125;<br>  F&gt;右向旗帜状节点] <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A  B(圆角矩形节点)  C[矩形节点]  D((圆形节点))  E&#123;菱形节点&#125;  F&gt;右向旗帜状节点]</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">    begin(出门)--&gt; buy[买炸鸡]</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB    begin(出门)--&gt; buy[买炸鸡]    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack    </code></pre><h5 id="连线">连线</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A1--&gt;B1<br>  A2---B2<br>  A3--text---B3<br>  A4--text--&gt;B4<br>  A5-.-B5<br>  A6-.-&gt;B6<br>  A7-.text.-B7<br>  A8-.text.-&gt;B8<br>  A9===B9<br>  A10==&gt;B10<br>  A11==text===B11<br>  A12==text==&gt;B12<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A1--&gt;B1  A2---B2  A3--text---B3  A4--text--&gt;B4  A5-.-B5  A6-.-&gt;B6  A7-.text.-B7  A8-.text.-&gt;B8  A9===B9  A10==&gt;B10  A11==text===B11  A12==text==&gt;B12</code></pre><pre><code class=" mermaid">graph TB A ---B</code></pre><h5 id="子图表">子图表</h5><p>使用以下语法添加子图表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">subgraph 子图表名称<br><span class="hljs-code">    子图表中的描述语句...</span><br><span class="hljs-code">end</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">  subgraph 买炸鸡前</span><br><span class="hljs-code">    begin(出门)--&gt; buy[出门买炸鸡]</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  subgraph 买炸鸡前    begin(出门)--&gt; buy[出门买炸鸡]    end    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</code></pre><h3 id="序列图sequence-diagram">序列图(sequence diagram)</h3><h4 id="概述-1">概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram <br><span class="hljs-code">[参与者1][消息线][参与者2]:消息体</span><br><span class="hljs-code">    ...</span><br></code></pre></td></tr></table></figure><blockquote><p><code>sequenceDiagram</code> 为每幅时序图的固定开头</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">Title: 买炸鸡</span><br><span class="hljs-code">    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？</span><br><span class="hljs-code">    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagramTitle: 买炸鸡    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</code></pre><h4 id="参与者participant">参与者（participant）</h4><p>传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 参与者 1</span><br><span class="hljs-code">    participant 参与者 2</span><br><span class="hljs-code">    ...</span><br><span class="hljs-code">    participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3</span><br></code></pre></td></tr></table></figure><blockquote><p><code>participant &lt;参与者名称&gt;</code>声明参与者，语句次序即为参与者横向排列次序。</p></blockquote><h4 id="消息线">消息线</h4><table><thead><tr class="header"><th style="text-align: left;">类型</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">-&gt;</td><td style="text-align: left;">无箭头的实线</td></tr><tr class="even"><td style="text-align: left;">--&gt;</td><td style="text-align: left;">无箭头的虚线</td></tr><tr class="odd"><td style="text-align: left;">-&gt;&gt;</td><td style="text-align: left;">有箭头的实线（主动发出消息）</td></tr><tr class="even"><td style="text-align: left;">–-&gt;&gt;</td><td style="text-align: left;">有箭头的虚线（响应）</td></tr><tr class="odd"><td style="text-align: left;">-x</td><td style="text-align: left;">末端为叉的实线（表示异步）</td></tr><tr class="even"><td style="text-align: left;">--x</td><td style="text-align: left;">末端为叉的虚线（表示异步）</td></tr></tbody></table><h4 id="处理中-激活框">处理中-激活框</h4><p>从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。</p><p>在消息线末尾增加 <code>+</code>，则消息接收者进入当前消息的“处理中”状态； 在消息线末尾增加<code>-</code> ，则消息接收者离开当前消息的“处理中”状态。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller:给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller:给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！    </code></pre><h4 id="注解note">注解（note）</h4><p>语法如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Note 位置表述 参与者: 标注文字<br></code></pre></td></tr></table></figure><p>其中位置表述可以为</p><table><thead><tr class="header"><th style="text-align: left;">表述</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">right of</td><td style="text-align: left;">右侧</td></tr><tr class="even"><td style="text-align: left;">left of</td><td style="text-align: left;">左侧</td></tr><tr class="odd"><td style="text-align: left;">over</td><td style="text-align: left;">在当中，可以横跨多个参与者</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    Note over 99,seller : 热爱炸鸡</span><br><span class="hljs-code">    Note left of 99 : 女</span><br><span class="hljs-code">    Note right of seller : 男</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller : 给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    Note over 99,seller : 热爱炸鸡    Note left of 99 : 女    Note right of seller : 男    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller : 给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="循环loop">循环（loop）</h4><p>在条件满足时，重复发出消息序列。（相当于编程语言中的 while语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">   </span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -&gt;&gt; +seller:给我炸！</span><br><span class="hljs-code">    loop 三分钟一次</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 我的炸鸡好了吗？</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 正在炸</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥       99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -&gt;&gt; +seller:给我炸！    loop 三分钟一次        99 -&gt;&gt; seller : 我的炸鸡好了吗？        seller --&gt;&gt; 99 : 正在炸    end    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="选择alt">选择（alt）</h4><p>在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及else if 语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram    <br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？</span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 可卖的炸鸡数</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    alt 可卖的炸鸡数 &gt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 买三只！</span><br><span class="hljs-code">    else 1 &lt; 可卖的炸鸡数 &lt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 有多少买多少</span><br><span class="hljs-code">    else 可卖的炸鸡数 &lt; 1</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 那我明天再来</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 欢迎下次光临</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram        participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？    seller --&gt;&gt; 99 : 可卖的炸鸡数        alt 可卖的炸鸡数 &gt; 3        99 -&gt;&gt; seller : 买三只！    else 1 &lt; 可卖的炸鸡数 &lt; 3        99 -&gt;&gt; seller : 有多少买多少    else 可卖的炸鸡数 &lt; 1        99 -&gt;&gt; seller : 那我明天再来    end    seller --&gt;&gt; 99 : 欢迎下次光临</code></pre><h4 id="可选opt">可选（opt）</h4><p>在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if语句。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 买炸鸡</span><br><span class="hljs-code">    opt 全都卖完了</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 下次再来</span><br><span class="hljs-code">    end</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 买炸鸡    opt 全都卖完了        seller --&gt;&gt; 99 : 下次再来    end</code></pre><h4 id="并行par">并行（Par）</h4><p>将消息序列分成多个片段，这些片段并行执行。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br>   participant 99 as 救救<br>   participant seller as 炸鸡店小哥<br>   <br><span class="hljs-code">    99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！</span><br><span class="hljs-code"></span><br><span class="hljs-code">    par 并行执行</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 装可乐</span><br><span class="hljs-code">    and</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 炸炸鸡</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram   participant 99 as 救救   participant seller as 炸鸡店小哥       99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！    par 并行执行        seller -&gt;&gt; seller : 装可乐    and        seller -&gt;&gt; seller : 炸炸鸡    end    seller --&gt;&gt; 99 : 您的炸鸡好了！</code></pre><h3 id="饼图pie">饼图（Pie）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">pie    title Pie Chart    &quot;Dogs&quot; : 386    &quot;Cats&quot; : 85    &quot;Rats&quot; : 150     &quot;panda&quot; : 200</code></pre><blockquote><p><ahref="http://support.typora.io/Draw-Diagrams-With-Markdown/">Typora支持mermaid的官方链接</a></p></blockquote><h3 id="甘特图gantt">甘特图（gantt）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"> title 标题<br>dateFormat 日期格式<br>section 部分名<br>任务名:参数一, 参数二, 参数三, 参数四，参数五<br><br> //参数一：crit（是否重要，红框框） 或者 不填<br> //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态)<br> //参数三：取小名 或者 不填<br> //参数四：任务开始时间<br> //参数五：任务结束时间<br></code></pre></td></tr></table></figure><blockquote><p><ahref="https://mermaid-js.github.io/mermaid/#/gantt">官方教程</a></p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gantt</span><br>       <span class="hljs-attribute">dateFormat</span>  YYYY-MM-DD<br>       <span class="hljs-attribute">title</span> Adding GANTT diagram functionality to mermaid<br><br>       <span class="hljs-attribute">section</span> A section<br>       <span class="hljs-attribute">Completed</span> task            :done,    des1, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span><br>       <span class="hljs-attribute">Active</span> task               :active,  des2, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span>, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task               :         des3, after des2, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Future</span> task2              :         des4, after des3, <span class="hljs-number">5</span>d<br><br>       <span class="hljs-attribute">section</span> Critical tasks<br>       <span class="hljs-attribute">Completed</span> task in the critical line :crit, done, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">24</span>h<br>       <span class="hljs-attribute">Implement</span> parser and jison          :crit, done, after des1, <span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Create</span> tests for parser             :crit, active, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task in critical line        :crit, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Create</span> tests for renderer           :<span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Add</span> to mermaid                      :<span class="hljs-number">1</span>d<br><br>       <span class="hljs-attribute">section</span> Documentation<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :active, a1, after des1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :after a1  , <span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :doc1, after a1  , <span class="hljs-number">48</span>h<br><br>       <span class="hljs-attribute">section</span> Last section<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :after doc1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :<span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :<span class="hljs-number">48</span>h<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">gantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/05/hello-world/"/>
    <url>/2024/04/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
